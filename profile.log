SCRIPT  /usr/share/nvim/runtime/syntax/lua.vim
Sourced 1 time
Total time:   0.003139
 Self time:   0.003075

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
                            " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:  2022 Sep 07
                            " Options:      lua_version = 4 or 5
                            "               lua_subversion = 0 (for 4.0 or 5.0)
                            "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
                            "               the default is 5.3
                            
                            " quit when a syntax file was already loaded
    1              0.000010 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
                            
    1              0.000013 let s:cpo_save = &cpo
    1   0.000052   0.000016 set cpo&vim
                            
    1              0.000005 if !exists("lua_version")
                              " Default is lua 5.3
                              let lua_version = 5
                              let lua_subversion = 3
    1              0.000003 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. In this case set it to 0
                              let lua_subversion = 0
    1              0.000001 endif
                            
    1              0.000002 syn case match
                            
                            " syncing method
    1              0.000003 syn sync minlines=1000
                            
    1              0.000002 if lua_version >= 5
    1              0.000005   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
    1              0.000003   syn keyword luaMetaMethod __eq __lt __le
    1              0.000002   syn keyword luaMetaMethod __index __newindex __call
    1              0.000004   syn keyword luaMetaMethod __metatable __mode __gc __tostring
    1              0.000001 endif
                            
    1              0.000004 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
    1              0.000002   syn keyword luaMetaMethod __mod __len
    1              0.000001 endif
                            
    1              0.000003 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000001   syn keyword luaMetaMethod __pairs
    1              0.000001 endif
                            
    1              0.000003 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
    1              0.000002   syn keyword luaMetaMethod __idiv __name
    1              0.000003   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
    1              0.000001 endif
                            
    1              0.000003 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
                              syn keyword luaMetaMethod __close
    1              0.000001 endif
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
                            
    1              0.000012 syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
    1              0.000004 syn match  luaParenError ")"
    1              0.000003 syn match  luaError "}"
    1              0.000009 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " Function declaration
    1              0.000009 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
                            
                            " else
    1              0.000004 syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
                            
                            " then ... end
    1              0.000007 syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
                            
                            " elseif ... then
    1              0.000008 syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
                            
                            " if ... then
    1              0.000009 syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
                            
                            " do ... end
    1              0.000007 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
                            " repeat ... until
    1              0.000006 syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
                            
                            " while ... do
    1              0.000007 syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000007 syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000003 syn keyword luaFor contained containedin=luaFor in
                            
                            " other keywords
    1              0.000003 syn keyword luaStatement return local break
    1              0.000004 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000002   syn keyword luaStatement goto
    1              0.000005   syn match luaLabel "::\I\i*::"
    1              0.000001 endif
                            
                            " operators
    1              0.000003 syn keyword luaOperator and or not
                            
    1              0.000003 if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
    1              0.000007   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
                            elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
                              syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
                            else
                              syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
    1              0.000001 endif
                            
                            " comments
    1              0.000003 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000007 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000008 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    1              0.000003 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000009   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000001 endif
                            
                            " first line may start with #!
    1              0.000004 syn match luaComment "\%^#!.*"
                            
    1              0.000003 syn keyword luaConstant nil
    1              0.000002 if lua_version > 4
    1              0.000003   syn keyword luaConstant true false
    1              0.000001 endif
                            
                            " strings
    1              0.000008 syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
    1              0.000001 if lua_version == 5
    1              0.000002   if lua_subversion == 0
                                syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    1              0.000001   else
    1              0.000002     if lua_subversion >= 2
    1              0.000005       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
    1              0.000001     endif
    1              0.000001     if lua_subversion >= 3
    1              0.000005       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
    1              0.000001     endif
    1              0.000007     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000001   endif
    1              0.000001 endif
    1              0.000010 syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000008 syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000005 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000007 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
                            " floating point number, starting with a dot, optional exponent
    1              0.000005 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000005 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000002 if lua_version >= 5
    1              0.000001   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    1              0.000002   elseif lua_subversion >= 2
    1              0.000006     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000001   endif
    1              0.000001 endif
                            
                            " tables
    1              0.000007 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
                            
                            " methods
    1              0.000005 syntax match luaFunc ":\@<=\k\+"
                            
                            " built-in functions
    1              0.000004 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000004 syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
                            
    1              0.000002 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    1              0.000001 elseif lua_version == 5
    1              0.000003   syn keyword luaFunc getmetatable setmetatable
    1              0.000002   syn keyword luaFunc ipairs pairs
    1              0.000002   syn keyword luaFunc pcall xpcall
    1              0.000004   syn keyword luaFunc _G loadfile rawequal require
    1              0.000002   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    1              0.000001   else
    1              0.000002     syn keyword luaFunc load select
    1              0.000005     syn match   luaFunc /\<package\.cpath\>/
    1              0.000004     syn match   luaFunc /\<package\.loaded\>/
    1              0.000004     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000004     syn match   luaFunc /\<package\.path\>/
    1              0.000004     syn match   luaFunc /\<package\.preload\>/
    1              0.000002     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    1              0.000002     elseif lua_subversion >= 2
    1              0.000002       syn keyword luaFunc _ENV rawlen
    1              0.000004       syn match   luaFunc /\<package\.config\>/
    1              0.000004       syn match   luaFunc /\<package\.preload\>/
    1              0.000004       syn match   luaFunc /\<package\.searchers\>/
    1              0.000004       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000001     endif
                            
    1              0.000001     if lua_subversion >= 3
    1              0.000005       syn match luaFunc /\<coroutine\.isyieldable\>/
    1              0.000001     endif
    1              0.000001     if lua_subversion >= 4
                                  syn keyword luaFunc warn
                                  syn match luaFunc /\<coroutine\.close\>/
    1              0.000001     endif
    1              0.000004     syn match luaFunc /\<coroutine\.running\>/
    1              0.000001   endif
    1              0.000004   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000004   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000004   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000004   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000004   syn match   luaFunc /\<coroutine\.yield\>/
                            
    1              0.000004   syn match   luaFunc /\<string\.byte\>/
    1              0.000004   syn match   luaFunc /\<string\.char\>/
    1              0.000006   syn match   luaFunc /\<string\.dump\>/
    1              0.000004   syn match   luaFunc /\<string\.find\>/
    1              0.000004   syn match   luaFunc /\<string\.format\>/
    1              0.000004   syn match   luaFunc /\<string\.gsub\>/
    1              0.000004   syn match   luaFunc /\<string\.len\>/
    1              0.000004   syn match   luaFunc /\<string\.lower\>/
    1              0.000004   syn match   luaFunc /\<string\.rep\>/
    1              0.000004   syn match   luaFunc /\<string\.sub\>/
    1              0.000004   syn match   luaFunc /\<string\.upper\>/
    1              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    1              0.000002   else
    1              0.000008     syn match luaFunc /\<string\.gmatch\>/
    1              0.000007     syn match luaFunc /\<string\.match\>/
    1              0.000005     syn match luaFunc /\<string\.reverse\>/
    1              0.000001   endif
    1              0.000002   if lua_subversion >= 3
    1              0.000004     syn match luaFunc /\<string\.pack\>/
    1              0.000004     syn match luaFunc /\<string\.packsize\>/
    1              0.000004     syn match luaFunc /\<string\.unpack\>/
    1              0.000004     syn match luaFunc /\<utf8\.char\>/
    1              0.000004     syn match luaFunc /\<utf8\.charpattern\>/
    1              0.000003     syn match luaFunc /\<utf8\.codes\>/
    1              0.000004     syn match luaFunc /\<utf8\.codepoint\>/
    1              0.000003     syn match luaFunc /\<utf8\.len\>/
    1              0.000004     syn match luaFunc /\<utf8\.offset\>/
    1              0.000001   endif
                            
    1              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    1              0.000002   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    1              0.000001   elseif lua_subversion >= 2
    1              0.000003     syn match luaFunc /\<table\.pack\>/
    1              0.000006     syn match luaFunc /\<table\.unpack\>/
    1              0.000002     if lua_subversion >= 3
    1              0.000004       syn match luaFunc /\<table\.move\>/
    1              0.000001     endif
    1              0.000001   endif
    1              0.000005   syn match   luaFunc /\<table\.concat\>/
    1              0.000004   syn match   luaFunc /\<table\.insert\>/
    1              0.000004   syn match   luaFunc /\<table\.sort\>/
    1              0.000004   syn match   luaFunc /\<table\.remove\>/
                            
    1              0.000002   if lua_subversion == 2
                                syn match   luaFunc /\<bit32\.arshift\>/
                                syn match   luaFunc /\<bit32\.band\>/
                                syn match   luaFunc /\<bit32\.bnot\>/
                                syn match   luaFunc /\<bit32\.bor\>/
                                syn match   luaFunc /\<bit32\.btest\>/
                                syn match   luaFunc /\<bit32\.bxor\>/
                                syn match   luaFunc /\<bit32\.extract\>/
                                syn match   luaFunc /\<bit32\.lrotate\>/
                                syn match   luaFunc /\<bit32\.lshift\>/
                                syn match   luaFunc /\<bit32\.replace\>/
                                syn match   luaFunc /\<bit32\.rrotate\>/
                                syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000001   endif
                            
    1              0.000004   syn match   luaFunc /\<math\.abs\>/
    1              0.000004   syn match   luaFunc /\<math\.acos\>/
    1              0.000004   syn match   luaFunc /\<math\.asin\>/
    1              0.000003   syn match   luaFunc /\<math\.atan\>/
    1              0.000002   if lua_subversion < 3
                                syn match   luaFunc /\<math\.atan2\>/
    1              0.000001   endif
    1              0.000006   syn match   luaFunc /\<math\.ceil\>/
    1              0.000004   syn match   luaFunc /\<math\.sin\>/
    1              0.000003   syn match   luaFunc /\<math\.cos\>/
    1              0.000003   syn match   luaFunc /\<math\.tan\>/
    1              0.000003   syn match   luaFunc /\<math\.deg\>/
    1              0.000004   syn match   luaFunc /\<math\.exp\>/
    1              0.000003   syn match   luaFunc /\<math\.floor\>/
    1              0.000003   syn match   luaFunc /\<math\.log\>/
    1              0.000003   syn match   luaFunc /\<math\.max\>/
    1              0.000003   syn match   luaFunc /\<math\.min\>/
    1              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    1              0.000002   elseif lua_subversion == 1
                                syn match luaFunc /\<math\.log10\>/
    1              0.000001   endif
    1              0.000001   if lua_subversion >= 1
    1              0.000004     syn match luaFunc /\<math\.huge\>/
    1              0.000004     syn match luaFunc /\<math\.fmod\>/
    1              0.000004     syn match luaFunc /\<math\.modf\>/
    1              0.000002     if lua_subversion == 1 || lua_subversion == 2
                                  syn match luaFunc /\<math\.cosh\>/
                                  syn match luaFunc /\<math\.sinh\>/
                                  syn match luaFunc /\<math\.tanh\>/
    1              0.000001     endif
    1              0.000001   endif
    1              0.000003   syn match   luaFunc /\<math\.rad\>/
    1              0.000003   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000002   if lua_subversion < 3
                                syn match   luaFunc /\<math\.pow\>/
                                syn match   luaFunc /\<math\.frexp\>/
                                syn match   luaFunc /\<math\.ldexp\>/
    1              0.000001   else
    1              0.000004     syn match   luaFunc /\<math\.maxinteger\>/
    1              0.000004     syn match   luaFunc /\<math\.mininteger\>/
    1              0.000004     syn match   luaFunc /\<math\.tointeger\>/
    1              0.000004     syn match   luaFunc /\<math\.type\>/
    1              0.000003     syn match   luaFunc /\<math\.ult\>/
    1              0.000001   endif
    1              0.000004   syn match   luaFunc /\<math\.random\>/
    1              0.000004   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000003   syn match   luaFunc /\<math\.pi\>/
                            
    1              0.000003   syn match   luaFunc /\<io\.close\>/
    1              0.000004   syn match   luaFunc /\<io\.flush\>/
    1              0.000004   syn match   luaFunc /\<io\.input\>/
    1              0.000003   syn match   luaFunc /\<io\.lines\>/
    1              0.000003   syn match   luaFunc /\<io\.open\>/
    1              0.000004   syn match   luaFunc /\<io\.output\>/
    1              0.000004   syn match   luaFunc /\<io\.popen\>/
    1              0.000003   syn match   luaFunc /\<io\.read\>/
    1              0.000003   syn match   luaFunc /\<io\.stderr\>/
    1              0.000003   syn match   luaFunc /\<io\.stdin\>/
    1              0.000004   syn match   luaFunc /\<io\.stdout\>/
    1              0.000004   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000003   syn match   luaFunc /\<io\.type\>/
    1              0.000003   syn match   luaFunc /\<io\.write\>/
                            
    1              0.000004   syn match   luaFunc /\<os\.clock\>/
    1              0.000003   syn match   luaFunc /\<os\.date\>/
    1              0.000004   syn match   luaFunc /\<os\.difftime\>/
    1              0.000004   syn match   luaFunc /\<os\.execute\>/
    1              0.000003   syn match   luaFunc /\<os\.exit\>/
    1              0.000003   syn match   luaFunc /\<os\.getenv\>/
    1              0.000003   syn match   luaFunc /\<os\.remove\>/
    1              0.000003   syn match   luaFunc /\<os\.rename\>/
    1              0.000004   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000004   syn match   luaFunc /\<os\.time\>/
    1              0.000004   syn match   luaFunc /\<os\.tmpname\>/
                            
    1              0.000008   syn match   luaFunc /\<debug\.debug\>/
    1              0.000004   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000004   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000006   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000004   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000004   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000006   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000004   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000004   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000002   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
    1              0.000001   endif
    1              0.000001   if lua_subversion >= 1
    1              0.000004     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000006     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000004     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000002     if lua_subversion >= 2
    1              0.000004       syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000004       syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000004       syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000005       syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000001     endif
    1              0.000001     if lua_subversion >= 4
                                  syn match luaFunc /\<debug.setcstacklimit\>/
    1              0.000001     endif
    1              0.000001   endif
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000003 hi def link luaStatement        Statement
    1              0.000002 hi def link luaRepeat           Repeat
    1              0.000001 hi def link luaFor              Repeat
    1              0.000001 hi def link luaString           String
    1              0.000001 hi def link luaString2          String
    1              0.000001 hi def link luaStringDelimiter  luaString
    1              0.000002 hi def link luaNumber           Number
    1              0.000001 hi def link luaOperator         Operator
    1              0.000001 hi def link luaSymbolOperator   luaOperator
    1              0.000002 hi def link luaConstant         Constant
    1              0.000002 hi def link luaCond             Conditional
    1              0.000001 hi def link luaCondElse         Conditional
    1              0.000001 hi def link luaFunction         Function
    1              0.000001 hi def link luaMetaMethod       Function
    1              0.000002 hi def link luaComment          Comment
    1              0.000001 hi def link luaCommentDelimiter luaComment
    1              0.000001 hi def link luaTodo             Todo
    1              0.000001 hi def link luaTable            Structure
    1              0.000001 hi def link luaError            Error
    1              0.000001 hi def link luaParenError       Error
    1              0.000002 hi def link luaSpecial          SpecialChar
    1              0.000001 hi def link luaFunc             Identifier
    1              0.000001 hi def link luaLabel            Label
                            
                            
    1              0.000005 let b:current_syntax = "lua"
                            
    1   0.000048   0.000020 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /usr/share/nvim/runtime/syntax/lsp_markdown.vim
Sourced 1 time
Total time:   0.042132
 Self time:   0.001956

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Markdown-like LSP docstrings
                            " Maintainer:   https://github.com/neovim/neovim
                            " URL:          http://neovim.io
                            " Remark:       Uses markdown syntax file
                            
                            " Source the default Nvim markdown syntax, not other random ones.
    1   0.040239   0.000063 execute 'source' expand('<sfile>:p:h') .. '/markdown.vim'
                            
    1              0.000005 syn cluster mkdNonListItem add=mkdEscape,mkdNbsp
                            
                            " Don't highlight invalid markdown syntax in LSP docstrings.
    1              0.000001 syn clear markdownError
                            
    1              0.000001 syn clear markdownEscape
    1              0.000015 syntax region markdownEscape matchgroup=markdownEscape start=/\\\ze[\\\x60*{}\[\]()#+\-,.!_>~|"$%&'\/:;<=?@^ ]/ end=/./ containedin=ALL keepend oneline concealends
                            
                            " Conceal backticks (which delimit code fragments).
                            " We ignore g:markdown_syntax_conceal here.
    1              0.000010 syn region markdownCode matchgroup=markdownCodeDelimiter start="`" end="`" keepend contains=markdownLineStart concealends
    1              0.000010 syn region markdownCode matchgroup=markdownCodeDelimiter start="`` \=" end=" \=``" keepend contains=markdownLineStart concealends
    1              0.000010 syn region markdownCode matchgroup=markdownCodeDelimiter start="^\s*````*.*$" end="^\s*````*\ze\s*$" keepend concealends
                            
                            " Highlight code fragments.
    1              0.000002 hi def link markdownCode Special
                            
                            " Conceal HTML entities.
    1              0.000006 syntax match mkdNbsp /&nbsp;/ conceal cchar= 
    1              0.000005 syntax match mkdLt /&lt;/  conceal cchar=<
    1              0.000005 syntax match mkdGt /&gt;/  conceal cchar=>
    1              0.000005 syntax match mkdAmp /&amp;/  conceal cchar=&
    1              0.000005 syntax match mkdQuot /&quot;/  conceal cchar="
                            
    1              0.000004 hi def link mkdEscape Special

SCRIPT  /usr/share/nvim/runtime/syntax/markdown.vim
Sourced 1 time
Total time:   0.040170
 Self time:   0.001902

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Markdown
                            " Maintainer:   Tim Pope <https://github.com/tpope/vim-markdown>
                            " Filenames:    *.markdown
                            " Last Change:  2022 Oct 13
                            
    1              0.000007 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
                            
    1              0.000003 if !exists('main_syntax')
    1              0.000004   let main_syntax = 'markdown'
    1              0.000001 endif
                            
    1              0.000004 if has('folding')
    1              0.000004   let s:foldmethod = &l:foldmethod
    1              0.000002   let s:foldtext = &l:foldtext
    1              0.000001 endif
    1              0.000002 let s:iskeyword = &l:iskeyword
                            
    1   0.035267   0.000432 runtime! syntax/html.vim
    1              0.000003 unlet! b:current_syntax
                            
    1              0.000006 if !exists('g:markdown_fenced_languages')
                              let g:markdown_fenced_languages = []
    1              0.000001 endif
    1              0.000004 let s:done_include = {}
    1              0.000010 for s:type in map(copy(g:markdown_fenced_languages),'matchstr(v:val,"[^=]*$")')
                              if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                continue
                              endif
                              if s:type =~ '\.'
                                let b:{matchstr(s:type,'[^.]*')}_subtype = matchstr(s:type,'\.\zs.*')
                              endif
                              syn case match
                              exe 'syn include @markdownHighlight_'.tr(s:type,'.','_').' syntax/'.matchstr(s:type,'[^.]*').'.vim'
                              unlet! b:current_syntax
                              let s:done_include[matchstr(s:type,'[^.]*')] = 1
    1              0.000002 endfor
    1              0.000002 unlet! s:type
    1              0.000002 unlet! s:done_include
                            
    1              0.000002 syn spell toplevel
    1              0.000006 if exists('s:foldmethod') && s:foldmethod !=# &l:foldmethod
                              let &l:foldmethod = s:foldmethod
                              unlet s:foldmethod
    1              0.000001 endif
    1              0.000004 if exists('s:foldtext') && s:foldtext !=# &l:foldtext
                              let &l:foldtext = s:foldtext
                              unlet s:foldtext
    1              0.000001 endif
    1              0.000003 if s:iskeyword !=# &l:iskeyword
                              let &l:iskeyword = s:iskeyword
    1              0.000001 endif
    1              0.000001 unlet s:iskeyword
                            
    1              0.000003 if !exists('g:markdown_minlines')
                              let g:markdown_minlines = 50
    1              0.000001 endif
    1              0.000007 execute 'syn sync minlines=' . g:markdown_minlines
    1              0.000001 syn sync linebreaks=1
    1              0.000001 syn case ignore
                            
    1              0.000012 syn match markdownValid '[<>]\c[a-z/$!]\@!' transparent contains=NONE
    1              0.000007 syn match markdownValid '&\%(#\=\w*;\)\@!' transparent contains=NONE
                            
    1              0.000008 syn match markdownLineStart "^[<@]\@!" nextgroup=@markdownBlock,htmlSpecialChar
                            
    1              0.000036 syn cluster markdownBlock contains=markdownH1,markdownH2,markdownH3,markdownH4,markdownH5,markdownH6,markdownBlockquote,markdownListMarker,markdownOrderedListMarker,markdownCodeBlock,markdownRule
    1              0.000010 syn cluster markdownInline contains=markdownLineBreak,markdownLinkText,markdownItalic,markdownBold,markdownCode,markdownEscape,@htmlTop,markdownError,markdownValid
                            
    1              0.000008 syn match markdownH1 "^.\+\n=\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
    1              0.000006 syn match markdownH2 "^.\+\n-\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
                            
    1              0.000004 syn match markdownHeadingRule "^[=-]\+$" contained
                            
    1              0.000013 syn region markdownH1 matchgroup=markdownH1Delimiter start=" \{,3}#\s"      end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000009 syn region markdownH2 matchgroup=markdownH2Delimiter start=" \{,3}##\s"     end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000007 syn region markdownH3 matchgroup=markdownH3Delimiter start=" \{,3}###\s"    end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000007 syn region markdownH4 matchgroup=markdownH4Delimiter start=" \{,3}####\s"   end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000007 syn region markdownH5 matchgroup=markdownH5Delimiter start=" \{,3}#####\s"  end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
    1              0.000008 syn region markdownH6 matchgroup=markdownH6Delimiter start=" \{,3}######\s" end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            
    1              0.000005 syn match markdownBlockquote ">\%(\s\|$\)" contained nextgroup=@markdownBlock
                            
    1              0.000009 syn region markdownCodeBlock start="^\n\( \{4,}\|\t\)" end="^\ze \{,3}\S.*$" keepend
                            
                            " TODO: real nesting
    1              0.000007 syn match markdownListMarker "\%(\t\| \{0,4\}\)[-*+]\%(\s\+\S\)\@=" contained
    1              0.000005 syn match markdownOrderedListMarker "\%(\t\| \{0,4}\)\<\d\+\.\%(\s\+\S\)\@=" contained
                            
    1              0.000004 syn match markdownRule "\* *\* *\*[ *]*$" contained
    1              0.000003 syn match markdownRule "- *- *-[ -]*$" contained
                            
    1              0.000004 syn match markdownLineBreak " \{2,\}$"
                            
    1              0.000014 syn region markdownIdDeclaration matchgroup=markdownLinkDelimiter start="^ \{0,3\}!\=\[" end="\]:" oneline keepend nextgroup=markdownUrl skipwhite
    1              0.000004 syn match markdownUrl "\S\+" nextgroup=markdownUrlTitle skipwhite contained
    1              0.000006 syn region markdownUrl matchgroup=markdownUrlDelimiter start="<" end=">" oneline keepend nextgroup=markdownUrlTitle skipwhite contained
    1              0.000005 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+"+ end=+"+ keepend contained
    1              0.000004 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+'+ end=+'+ keepend contained
    1              0.000004 syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+(+ end=+)+ keepend contained
                            
    1              0.000017 syn region markdownLinkText matchgroup=markdownLinkTextDelimiter start="!\=\[\%(\_[^][]*\%(\[\_[^][]*\]\_[^][]*\)*]\%( \=[[(]\)\)\@=" end="\]\%( \=[[(]\)\@=" nextgroup=markdownLink,markdownId skipwhite contains=@markdownInline,markdownLineStart
    1              0.000006 syn region markdownLink matchgroup=markdownLinkDelimiter start="(" end=")" contains=markdownUrl keepend contained
    1              0.000004 syn region markdownId matchgroup=markdownIdDelimiter start="\[" end="\]" keepend contained
    1              0.000009 syn region markdownAutomaticLink matchgroup=markdownUrlDelimiter start="<\%(\w\+:\|[[:alnum:]_+-]\+@\)\@=" end=">" keepend oneline
                            
    1              0.000003 let s:concealends = ''
    1              0.000008 if has('conceal') && get(g:, 'markdown_syntax_conceal', 1) == 1
    1              0.000002   let s:concealends = ' concealends'
    1              0.000001 endif
    1              0.000019 exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\*\S\@=" end="\S\@<=\*\|^$" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000017 exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\w\@<!_\S\@=" end="\S\@<=_\w\@!\|^$" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000016 exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\*\*\S\@=" end="\S\@<=\*\*\|^$" skip="\\\*" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
    1              0.000015 exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\w\@<!__\S\@=" end="\S\@<=__\w\@!\|^$" skip="\\_" contains=markdownLineStart,markdownItalic,@Spell' . s:concealends
    1              0.000015 exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\*\*\*\S\@=" end="\S\@<=\*\*\*\|^$" skip="\\\*" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000028 exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\w\@<!___\S\@=" end="\S\@<=___\w\@!\|^$" skip="\\_" contains=markdownLineStart,@Spell' . s:concealends
    1              0.000014 exe 'syn region markdownStrike matchgroup=markdownStrikeDelimiter start="\~\~\S\@=" end="\S\@<=\~\~\|^$" contains=markdownLineStart,@Spell' . s:concealends
                            
    1              0.000007 syn region markdownCode matchgroup=markdownCodeDelimiter start="`" end="`" keepend contains=markdownLineStart
    1              0.000007 syn region markdownCode matchgroup=markdownCodeDelimiter start="`` \=" end=" \=``" keepend contains=markdownLineStart
    1              0.000009 syn region markdownCodeBlock matchgroup=markdownCodeDelimiter start="^\s*\z(`\{3,\}\).*$" end="^\s*\z1\ze\s*$" keepend
    1              0.000008 syn region markdownCodeBlock matchgroup=markdownCodeDelimiter start="^\s*\z(\~\{3,\}\).*$" end="^\s*\z1\ze\s*$" keepend
                            
    1              0.000006 syn match markdownFootnote "\[^[^\]]\+\]"
    1              0.000083 syn match markdownFootnoteDefinition "^\[^[^\]]\+\]:"
                            
    1              0.000004 let s:done_include = {}
    1              0.000004 for s:type in g:markdown_fenced_languages
                              if has_key(s:done_include, matchstr(s:type,'[^.]*'))
                                continue
                              endif
                              exe 'syn region markdownHighlight_'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*\z(`\{3,\}\)\s*\%({.\{-}\.\)\='.matchstr(s:type,'[^=]*').'}\=\S\@!.*$" end="^\s*\z1\ze\s*$" keepend contains=@markdownHighlight_'.tr(matchstr(s:type,'[^=]*$'),'.','_') . s:concealends
                              exe 'syn region markdownHighlight_'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*\z(\~\{3,\}\)\s*\%({.\{-}\.\)\='.matchstr(s:type,'[^=]*').'}\=\S\@!.*$" end="^\s*\z1\ze\s*$" keepend contains=@markdownHighlight_'.tr(matchstr(s:type,'[^=]*$'),'.','_') . s:concealends
                              let s:done_include[matchstr(s:type,'[^.]*')] = 1
    1              0.000001 endfor
    1              0.000002 unlet! s:type
    1              0.000002 unlet! s:done_include
                            
    1              0.000007 if get(b:, 'markdown_yaml_head', get(g:, 'markdown_yaml_head', main_syntax ==# 'markdown'))
    1   0.003921   0.000488   syn include @markdownYamlTop syntax/yaml.vim
    1              0.000006   unlet! b:current_syntax
    1              0.000028   syn region markdownYamlHead start="\%^---$" end="^\%(---\|\.\.\.\)\s*$" keepend contains=@markdownYamlTop,@Spell
    1              0.000002 endif
                            
    1              0.000008 syn match markdownEscape "\\[][\\`*_{}()<>#+.!-]"
    1              0.000007 syn match markdownError "\w\@<=_\w\@="
                            
    1              0.000003 hi def link markdownH1                    htmlH1
    1              0.000002 hi def link markdownH2                    htmlH2
    1              0.000001 hi def link markdownH3                    htmlH3
    1              0.000001 hi def link markdownH4                    htmlH4
    1              0.000002 hi def link markdownH5                    htmlH5
    1              0.000002 hi def link markdownH6                    htmlH6
    1              0.000002 hi def link markdownHeadingRule           markdownRule
    1              0.000002 hi def link markdownH1Delimiter           markdownHeadingDelimiter
    1              0.000002 hi def link markdownH2Delimiter           markdownHeadingDelimiter
    1              0.000002 hi def link markdownH3Delimiter           markdownHeadingDelimiter
    1              0.000002 hi def link markdownH4Delimiter           markdownHeadingDelimiter
    1              0.000001 hi def link markdownH5Delimiter           markdownHeadingDelimiter
    1              0.000002 hi def link markdownH6Delimiter           markdownHeadingDelimiter
    1              0.000002 hi def link markdownHeadingDelimiter      Delimiter
    1              0.000002 hi def link markdownOrderedListMarker     markdownListMarker
    1              0.000002 hi def link markdownListMarker            htmlTagName
    1              0.000002 hi def link markdownBlockquote            Comment
    1              0.000002 hi def link markdownRule                  PreProc
                            
    1              0.000002 hi def link markdownFootnote              Typedef
    1              0.000002 hi def link markdownFootnoteDefinition    Typedef
                            
    1              0.000002 hi def link markdownLinkText              htmlLink
    1              0.000002 hi def link markdownIdDeclaration         Typedef
    1              0.000002 hi def link markdownId                    Type
    1              0.000002 hi def link markdownAutomaticLink         markdownUrl
    1              0.000001 hi def link markdownUrl                   Float
    1              0.000002 hi def link markdownUrlTitle              String
    1              0.000002 hi def link markdownIdDelimiter           markdownLinkDelimiter
    1              0.000002 hi def link markdownUrlDelimiter          htmlTag
    1              0.000002 hi def link markdownUrlTitleDelimiter     Delimiter
                            
    1              0.000002 hi def link markdownItalic                htmlItalic
    1              0.000002 hi def link markdownItalicDelimiter       markdownItalic
    1              0.000002 hi def link markdownBold                  htmlBold
    1              0.000002 hi def link markdownBoldDelimiter         markdownBold
    1              0.000002 hi def link markdownBoldItalic            htmlBoldItalic
    1              0.000002 hi def link markdownBoldItalicDelimiter   markdownBoldItalic
    1              0.000002 hi def link markdownStrike                htmlStrike
    1              0.000002 hi def link markdownStrikeDelimiter       markdownStrike
    1              0.000002 hi def link markdownCodeDelimiter         Delimiter
                            
    1              0.000001 hi def link markdownEscape                Special
    1              0.000001 hi def link markdownError                 Error
                            
    1              0.000004 let b:current_syntax = "markdown"
    1              0.000004 if main_syntax ==# 'markdown'
    1              0.000002   unlet main_syntax
    1              0.000001 endif
                            
                            " vim:set sw=2:

SCRIPT  /usr/share/nvim/runtime/syntax/html.vim
Sourced 1 time
Total time:   0.034830
 Self time:   0.006163

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:		HTML
                            " Maintainer:		Doug Kearns <dougkearns@gmail.com>
                            " Previous Maintainers: Jorge Maldonado Ventura <jorgesumle@freakspot.net>
                            "			Claudio Fleiner <claudio@fleiner.com>
                            " Last Change:		2023 Feb 20
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " quit when a syntax file was already loaded
    1              0.000006 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'html'
    1              0.000001 endif
                            
    1              0.000009 let s:cpo_save = &cpo
    1   0.000050   0.000016 set cpo&vim
                            
    1              0.000002 syntax spell toplevel
                            
    1   0.005703   0.000411 syn include @htmlXml syntax/xml.vim
    1              0.000002 unlet b:current_syntax
                            
    1              0.000001 syn case ignore
                            
                            " mark illegal characters
    1              0.000006 syn match htmlError "[<>&]"
                            
                            
                            " tags
    1              0.000010 syn region  htmlString	 contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000009 syn region  htmlString	 contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    1              0.000011 syn match   htmlValue	 contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    1              0.000008 syn region  htmlEndTag		   start=+</+	   end=+>+ contains=htmlTagN,htmlTagError
    1              0.000013 syn region  htmlTag		   start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    1              0.000010 syn match   htmlTagN	 contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000008 syn match   htmlTagN	 contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    1              0.000004 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    1              0.000005 syn keyword htmlTagName contained address applet area a base basefont
    1              0.000004 syn keyword htmlTagName contained big blockquote br caption center
    1              0.000006 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    1              0.000003 syn keyword htmlTagName contained form hr html img
    1              0.000004 syn keyword htmlTagName contained input isindex kbd li link map menu
    1              0.000004 syn keyword htmlTagName contained meta ol option param pre p samp span
    1              0.000004 syn keyword htmlTagName contained select small strike sub sup
    1              0.000004 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    1              0.000009 syn match   htmlTagName contained "\<\%(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    1              0.000004 syn keyword htmlTagName contained abbr acronym bdo button col colgroup
    1              0.000003 syn keyword htmlTagName contained del fieldset iframe ins label legend
    1              0.000004 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " new html 5 tags
    1              0.000003 syn keyword htmlTagName contained article aside audio bdi canvas data
    1              0.000003 syn keyword htmlTagName contained datalist details dialog embed figcaption
    1              0.000003 syn keyword htmlTagName contained figure footer header hgroup keygen main
    1              0.000003 syn keyword htmlTagName contained mark menuitem meter nav output picture
    1              0.000003 syn keyword htmlTagName contained progress rb rp rt rtc ruby section
    1              0.000004 syn keyword htmlTagName contained slot source summary template time track
    1              0.000002 syn keyword htmlTagName contained video wbr
                            
                            " svg and math tags
    1              0.000002 syn keyword htmlMathTagName contained math
    1              0.000002 syn keyword htmlSvgTagName  contained svg
                            
    1              0.000009 syn region  htmlMath start="<math>" end="</math>" contains=@htmlXml transparent keepend
    1              0.000007 syn region  htmlSvg  start="<svg>"  end="</svg>"  contains=@htmlXml transparent keepend
                            
    1              0.000003 syn cluster xmlTagHook	add=htmlMathTagName,htmlSvgTagName
                            
                            " legal arg names
    1              0.000002 syn keyword htmlArg contained action
    1              0.000004 syn keyword htmlArg contained align alink alt archive background bgcolor
    1              0.000002 syn keyword htmlArg contained border bordercolor cellpadding
    1              0.000004 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    1              0.000004 syn keyword htmlArg contained cols colspan content coords enctype face
    1              0.000002 syn keyword htmlArg contained gutter height hspace id
    1              0.000002 syn keyword htmlArg contained link lowsrc marginheight
    1              0.000003 syn keyword htmlArg contained marginwidth maxlength method name prompt
    1              0.000003 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    1              0.000003 syn keyword htmlArg contained size src start target text type url
    1              0.000004 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    1              0.000006 syn match   htmlArg contained "\<\%(http-equiv\|href\|title\)="me=e-1
                            
                            " aria attributes
    1              0.000115 exe 'syn match htmlArg contained "\<aria-\%(' . join([
                                \ 'activedescendant', 'atomic', 'autocomplete', 'busy', 'checked', 'colcount',
                                \ 'colindex', 'colspan', 'controls', 'current', 'describedby', 'details',
                                \ 'disabled', 'dropeffect', 'errormessage', 'expanded', 'flowto', 'grabbed',
                                \ 'haspopup', 'hidden', 'invalid', 'keyshortcuts', 'label', 'labelledby', 'level',
                                \ 'live', 'modal', 'multiline', 'multiselectable', 'orientation', 'owns',
                                \ 'placeholder', 'posinset', 'pressed', 'readonly', 'relevant', 'required',
                                \ 'roledescription', 'rowcount', 'rowindex', 'rowspan', 'selected', 'setsize',
                                \ 'sort', 'valuemax', 'valuemin', 'valuenow', 'valuetext'
                                \ ], '\|') . '\)\>"'
    1              0.000003 syn keyword htmlArg contained role
                            
                            " Netscape extensions
    1              0.000007 syn keyword htmlTagName contained frame noframes frameset nobr blink
    1              0.000003 syn keyword htmlTagName contained layer ilayer nolayer spacer
    1              0.000003 syn keyword htmlArg	contained frameborder noresize pagex pagey above below
    1              0.000003 syn keyword htmlArg	contained left top visibility clip id noshade
    1              0.000004 syn match   htmlArg	contained "\<z-index\>"
                            
                            " Microsoft extensions
    1              0.000002 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    1              0.000005 syn match   htmlArg contained "\<\%(accept-charset\|label\)\>"
    1              0.000004 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    1              0.000004 syn keyword htmlArg contained cite classid codetype compact data datetime
    1              0.000004 syn keyword htmlArg contained declare defer dir disabled for frame
    1              0.000003 syn keyword htmlArg contained headers hreflang lang language longdesc
    1              0.000003 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    1              0.000003 syn keyword htmlArg contained rules scheme scope span standby style
    1              0.000003 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " html 5 arg names
    1              0.000003 syn keyword htmlArg contained allow autocapitalize as blocking decoding
    1              0.000003 syn keyword htmlArg contained enterkeyhint imagesizes imagesrcset inert
    1              0.000003 syn keyword htmlArg contained integrity is itemid itemprop itemref itemscope
    1              0.000003 syn keyword htmlArg contained itemtype loading nomodule ping playsinline
    1              0.000003 syn keyword htmlArg contained referrerpolicy slot allowfullscreen async
    1              0.000002 syn keyword htmlArg contained autocomplete autofocus autoplay challenge
    1              0.000003 syn keyword htmlArg contained contenteditable contextmenu controls crossorigin
    1              0.000003 syn keyword htmlArg contained default dirname download draggable dropzone form
    1              0.000003 syn keyword htmlArg contained formaction formenctype formmethod formnovalidate
    1              0.000003 syn keyword htmlArg contained formtarget hidden high icon inputmode keytype
    1              0.000004 syn keyword htmlArg contained kind list loop low max min minlength muted nonce
    1              0.000003 syn keyword htmlArg contained novalidate open optimum pattern placeholder
    1              0.000003 syn keyword htmlArg contained poster preload radiogroup required reversed
    1              0.000003 syn keyword htmlArg contained sandbox spellcheck sizes srcset srcdoc srclang
    1              0.000003 syn keyword htmlArg contained step title translate typemustmatch
    1              0.000007 syn match   htmlArg contained "\<data-\h\%(\w\|[-.]\)*\%(\_s*=\)\@="
                            
                            " special characters
    1              0.000010 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    1              0.000005 if exists("html_wrong_comments")
                              syn region htmlComment	start=+<!--+	end=+--\s*>+	contains=@Spell
    1              0.000001 else
                              " The HTML 5.2 syntax 8.2.4.41: bogus comment is parser error; browser skips until next &gt
    1              0.000008   syn region htmlComment	start=+<!+	end=+>+		contains=htmlCommentError keepend
                              " Idem 8.2.4.42,51: Comment starts with <!-- and ends with -->
                              " Idem 8.2.4.43,44: Except <!--> and <!---> are parser errors
                              " Idem 8.2.4.52: dash-dash-bang (--!>) is error ignored by parser, also closes comment
    1              0.000012   syn region htmlComment matchgroup=htmlComment start=+<!--\%(-\?>\)\@!+	end=+--!\?>+	contains=htmlCommentNested,@htmlPreProc,@Spell keepend
                              " Idem 8.2.4.49: nested comment is parser error, except <!--> is all right
    1              0.000004   syn match htmlCommentNested contained "<!-->\@!"
    1              0.000003   syn match htmlCommentError  contained "[^><!]"
    1              0.000001 endif
    1              0.000007 syn region htmlComment	start=+<!DOCTYPE+	end=+>+ keepend
                            
                            " server-parsed commands
    1              0.000012 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    1              0.000012 syn match htmlPreStmt contained "<!--#\%(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    1              0.000004 syn match htmlPreError contained "<!--#\S*"ms=s+4
    1              0.000007 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    1              0.000009 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    1              0.000003 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    1              0.000009 syn match htmlPreProcAttrName contained "\%(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    1              0.000004 if !exists("html_no_rendering")
                              " rendering
    1              0.000009   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    1              0.000009   syn region htmlStrike start="<del\>" end="</del\_s*>"me=s-1 contains=@htmlTop
    1              0.000007   syn region htmlStrike start="<s\>" end="</s\_s*>"me=s-1 contains=@htmlTop
    1              0.000007   syn region htmlStrike start="<strike\>" end="</strike\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000008   syn region htmlBold start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000009   syn region htmlBold start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    1              0.000007   syn region htmlBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
    1              0.000007   syn region htmlBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000006   syn region htmlBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlBoldItalicUnderline
    1              0.000006   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    1              0.000007   syn region htmlUnderline start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    1              0.000006   syn region htmlUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000007   syn region htmlUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineBoldItalic
    1              0.000006   syn region htmlUnderlineItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000006   syn region htmlUnderlineItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop,htmlUnderlineItalicBold
    1              0.000006   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000007   syn region htmlItalic start="<i\>" end="</i\_s*>"me=s-1 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    1              0.000006   syn region htmlItalic start="<em\>" end="</em\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlItalicBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000015   syn region htmlItalicBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop,htmlItalicBoldUnderline
    1              0.000006   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlItalicUnderline contained start="<u\>" end="</u\_s*>"me=s-1 contains=@htmlTop,htmlItalicUnderlineBold
    1              0.000005   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong\_s*>"me=s-1 contains=@htmlTop
                            
    1              0.000004   syn match htmlLeadingSpace "^\s\+" contained
    1              0.000014   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a\_s*>"me=s-1 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    1              0.000009   syn region htmlH1 start="<h1\>" end="</h1\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH2 start="<h2\>" end="</h2\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH3 start="<h3\>" end="</h3\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH4 start="<h4\>" end="</h4\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH5 start="<h5\>" end="</h5\_s*>"me=s-1 contains=@htmlTop
    1              0.000006   syn region htmlH6 start="<h6\>" end="</h6\_s*>"me=s-1 contains=@htmlTop
    1              0.000017   syn region htmlHead start="<head\>" end="</head\_s*>"me=s-1 end="<body\>"me=s-1 end="<h[1-6]\>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    1              0.000011   syn region htmlTitle start="<title\>" end="</title\_s*>"me=s-1 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000002 syn keyword htmlTagName		contained noscript
    1              0.000003 syn keyword htmlSpecialTagName	contained script style
    1              0.000005 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
    1   0.001606   0.000482   syn include @htmlJavaScript syntax/javascript.vim
    1              0.000004   unlet b:current_syntax
    1              0.000018   syn region  javaScript start=+<script\>\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000010   syn region  htmlScriptTag	contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
    1              0.000002   hi def link htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
    1              0.000005   if exists("html_extended_events")
                                syn region htmlEvent	contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent	contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
    1              0.000001   else
    1              0.000006     syn region htmlEvent	contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
    1              0.000006     syn region htmlEvent	contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
    1              0.000001   endif
    1              0.000005   syn region htmlEventSQ	contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
    1              0.000005   syn region htmlEventDQ	contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
    1              0.000002   hi def link htmlEventSQ htmlEvent
    1              0.000001   hi def link htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
    1              0.000006   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000004 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
    1   0.004216   0.000423   syn include @htmlVbScript syntax/vb.vim
    1              0.000004   unlet b:current_syntax
    1              0.000019   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    1              0.000001 endif
                            
    1              0.000004 syn cluster htmlJavaScript	add=@htmlPreproc
                            
    1              0.000006 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
    1              0.000002   syn keyword htmlArg		contained media
    1   0.018840   0.000465   syn include @htmlCss syntax/css.vim
    1              0.000003   unlet b:current_syntax
    1              0.000019   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
    1              0.000006   syn match htmlCssStyleComment contained "\%(<!--\|-->\)"
    1              0.002378   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
    1              0.000007   hi def link htmlStyleArg htmlString
    1              0.000002 endif
                            
    1              0.000008 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
                              syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
                              syn sync match htmlHighlight groupthere javaScript "<script"
                              syn sync match htmlHighlightSkip "^.*['\"].*$"
                              syn sync minlines=10
    1              0.000001 endif
                            
                            " Folding
                            " Originally by Ingo Karkat and Marcus Zanona
    1              0.000009 if get(g:, "html_syntax_folding", 0)
                              syn region htmlFold start="<\z(\<\%(area\|base\|br\|col\|command\|embed\|hr\|img\|input\|keygen\|link\|meta\|param\|source\|track\|wbr\>\)\@![a-z-]\+\>\)\%(\_s*\_[^/]\?>\|\_s\_[^>]*\_[^>/]>\)" end="</\z1\_s*>" fold transparent keepend extend containedin=htmlHead,htmlH\d
                              " fold comments (the real ones and the old Netscape ones)
                              if exists("html_wrong_comments")
                                syn region htmlComment start=+<!--+ end=+--\s*>\%(\n\s*<!--\)\@!+ contains=@Spell fold
                              endif
    1              0.000001 endif
                            
                            " The default highlighting.
    1              0.000002 hi def link htmlTag			Function
    1              0.000002 hi def link htmlEndTag			Identifier
    1              0.000001 hi def link htmlArg			Type
    1              0.000002 hi def link htmlTagName			htmlStatement
    1              0.000002 hi def link htmlSpecialTagName		Exception
    1              0.000001 hi def link htmlMathTagName		htmlTagName
    1              0.000001 hi def link htmlSvgTagName		htmlTagName
    1              0.000002 hi def link htmlValue			String
    1              0.000001 hi def link htmlSpecialChar		Special
                            
    1              0.000005 if !exists("html_no_rendering")
    1              0.000002   hi def link htmlH1			  Title
    1              0.000001   hi def link htmlH2			  htmlH1
    1              0.000001   hi def link htmlH3			  htmlH2
    1              0.000001   hi def link htmlH4			  htmlH3
    1              0.000001   hi def link htmlH5			  htmlH4
    1              0.000001   hi def link htmlH6			  htmlH5
    1              0.000001   hi def link htmlHead			  PreProc
    1              0.000002   hi def link htmlTitle			  Title
    1              0.000002   hi def link htmlBoldItalicUnderline	  htmlBoldUnderlineItalic
    1              0.000002   hi def link htmlUnderlineBold		  htmlBoldUnderline
    1              0.000002   hi def link htmlUnderlineItalicBold	  htmlBoldUnderlineItalic
    1              0.000002   hi def link htmlUnderlineBoldItalic	  htmlBoldUnderlineItalic
    1              0.000002   hi def link htmlItalicUnderline	  htmlUnderlineItalic
    1              0.000002   hi def link htmlItalicBold		  htmlBoldItalic
    1              0.000002   hi def link htmlItalicBoldUnderline	  htmlBoldUnderlineItalic
    1              0.000002   hi def link htmlItalicUnderlineBold	  htmlBoldUnderlineItalic
    1              0.000002   hi def link htmlLink			  Underlined
    1              0.000002   hi def link htmlLeadingSpace		  None
    1              0.000003   if !exists("html_my_rendering")
    1              0.000002     hi def htmlBold		   term=bold cterm=bold gui=bold
    1              0.000002     hi def htmlBoldUnderline	   term=bold,underline cterm=bold,underline gui=bold,underline
    1              0.000002     hi def htmlBoldItalic	   term=bold,italic cterm=bold,italic gui=bold,italic
    1              0.000002     hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    1              0.000002     hi def htmlUnderline	   term=underline cterm=underline gui=underline
    1              0.000002     hi def htmlUnderlineItalic	   term=italic,underline cterm=italic,underline gui=italic,underline
    1              0.000001     hi def htmlItalic		   term=italic cterm=italic gui=italic
    1              0.000005     if v:version > 800 || v:version == 800 && has("patch1038")
    1              0.000002 	hi def htmlStrike	       term=strikethrough cterm=strikethrough gui=strikethrough
                                else
                            	hi def htmlStrike	       term=underline cterm=underline gui=underline
    1              0.000001     endif
    1              0.000001   endif
    1              0.000001 endif
                            
    1              0.000002 hi def link htmlPreStmt		   PreProc
    1              0.000002 hi def link htmlPreError	   Error
    1              0.000001 hi def link htmlPreProc		   PreProc
    1              0.000001 hi def link htmlPreAttr		   String
    1              0.000002 hi def link htmlPreProcAttrName    PreProc
    1              0.000002 hi def link htmlPreProcAttrError   Error
    1              0.000001 hi def link htmlString		   String
    1              0.000002 hi def link htmlStatement	   Statement
    1              0.000001 hi def link htmlComment		   Comment
    1              0.000002 hi def link htmlCommentNested	   htmlError
    1              0.000001 hi def link htmlCommentError	   htmlError
    1              0.000001 hi def link htmlTagError	   htmlError
    1              0.000002 hi def link htmlEvent		   javaScript
    1              0.000001 hi def link htmlError		   Error
                            
    1              0.000001 hi def link javaScript		   Special
    1              0.000001 hi def link javaScriptExpression   javaScript
    1              0.000001 hi def link htmlCssStyleComment    Comment
    1              0.000001 hi def link htmlCssDefinition	   Special
                            
    1              0.000005 let b:current_syntax = "html"
                            
    1              0.000003 if main_syntax == 'html'
                              unlet main_syntax
    1              0.000001 endif
                            
    1   0.000075   0.000026 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/xml.vim
Sourced 1 time
Total time:   0.005287
 Self time:   0.000738

count  total (s)   self (s)
                            " Vim syntax file
                            " Language: XML
                            " Maintainer: Christian Brabandt <cb@256bit.org>
                            " Repository: https://github.com/chrisbra/vim-xml-ftplugin
                            " Previous Maintainer: Johannes Zellner <johannes@zellner.org>
                            " Author: Paul Siegmann <pauls@euronet.nl>
                            " Last Changed:	Nov 03, 2019
                            " Filenames:	*.xml
                            " Last Change:
                            " 20190923 - Fix xmlEndTag to match xmlTag (vim/vim#884)
                            " 20190924 - Fix xmlAttribute property (amadeus/vim-xml@d8ce1c946)
                            " 20191103 - Enable spell checking globally
                            " 20210428 - Improve syntax synchronizing
                            
                            " CONFIGURATION:
                            "   syntax folding can be turned on by
                            "
                            "      let g:xml_syntax_folding = 1
                            "
                            "   before the syntax file gets loaded (e.g. in ~/.vimrc).
                            "   This might slow down syntax highlighting significantly,
                            "   especially for large files.
                            "
                            " CREDITS:
                            "   The original version was derived by Paul Siegmann from
                            "   Claudio Fleiner's html.vim.
                            "
                            " REFERENCES:
                            "   [1] http://www.w3.org/TR/2000/REC-xml-20001006
                            "   [2] http://www.w3.org/XML/1998/06/xmlspec-report-19980910.htm
                            "
                            "   as <hirauchi@kiwi.ne.jp> pointed out according to reference [1]
                            "
                            "   2.3 Common Syntactic Constructs
                            "   [4]    NameChar    ::=    Letter | Digit | '.' | '-' | '_' | ':' | CombiningChar | Extender
                            "   [5]    Name        ::=    (Letter | '_' | ':') (NameChar)*
                            "
                            " NOTE:
                            "   1) empty tag delimiters "/>" inside attribute values (strings)
                            "      confuse syntax highlighting.
                            "   2) for large files, folding can be pretty slow, especially when
                            "      loading a file the first time and viewoptions contains 'folds'
                            "      so that folds of previous sessions are applied.
                            "      Don't use 'foldmethod=syntax' in this case.
                            
                            
                            " Quit when a syntax file was already loaded
    1              0.000007 if exists("b:current_syntax")
                                finish
    1              0.000001 endif
                            
    1              0.000008 let s:xml_cpo_save = &cpo
    1   0.000038   0.000010 set cpo&vim
                            
    1              0.000001 syn case match
                            
                            " Allow spell checking in tag values,
                            " there is no syntax region for that,
                            " so enable spell checking in top-level elements
                            " <tag>This text is spell checked</tag>
    1              0.000001 syn spell toplevel
                            
                            " mark illegal characters
    1              0.000007 syn match xmlError "[<&]"
                            
                            " strings (inside tags) aka VALUES
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "                      ^^^^^^^
    1              0.000010 syn region  xmlString contained start=+"+ end=+"+ contains=xmlEntity,@Spell display
    1              0.000006 syn region  xmlString contained start=+'+ end=+'+ contains=xmlEntity,@Spell display
                            
                            
                            " punctuation (within attributes) e.g. <tag xml:foo.attribute ...>
                            "                                              ^   ^
                            " syn match   xmlAttribPunct +[-:._]+ contained display
    1              0.000003 syn match   xmlAttribPunct +[:.]+ contained display
                            
                            " no highlighting for xmlEqual (xmlEqual has no highlighting group)
    1              0.000005 syn match   xmlEqual +=+ display
                            
                            
                            " attribute, everything before the '='
                            "
                            " PROVIDES: @xmlAttribHook
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "      ^^^^^^^^^^^^^
                            "
    1              0.000014 syn match   xmlAttrib
                                \ +[-'"<]\@1<!\<[a-zA-Z:_][-.0-9a-zA-Z:_]*\>\%(['"]\@!\|$\)+
                                \ contained
                                \ contains=xmlAttribPunct,@xmlAttribHook
                                \ display
                            
                            
                            " namespace spec
                            "
                            " PROVIDES: @xmlNamespaceHook
                            "
                            " EXAMPLE:
                            "
                            " <xsl:for-each select = "lola">
                            "  ^^^
                            "
    1              0.000004 if exists("g:xml_namespace_transparent")
                            syn match   xmlNamespace
                                \ +\(<\|</\)\@2<=[^ /!?<>"':]\+[:]\@=+
                                \ contained
                                \ contains=@xmlNamespaceHook
                                \ transparent
                                \ display
    1              0.000001 else
    1              0.000008 syn match   xmlNamespace
                                \ +\(<\|</\)\@2<=[^ /!?<>"':]\+[:]\@=+
                                \ contained
                                \ contains=@xmlNamespaceHook
                                \ display
    1              0.000001 endif
                            
                            
                            " tag name
                            "
                            " PROVIDES: @xmlTagHook
                            "
                            " EXAMPLE:
                            "
                            " <tag foo.attribute = "value">
                            "  ^^^
                            "
    1              0.000008 syn match   xmlTagName
                                \ +\%(<\|</\)\@2<=[^ /!?<>"']\++
                                \ contained
                                \ contains=xmlNamespace,xmlAttribPunct,@xmlTagHook
                                \ display
                            
                            
    1              0.000003 if exists('g:xml_syntax_folding')
                            
                                " start tag
                                " use matchgroup=xmlTag to skip over the leading '<'
                                "
                                " PROVIDES: @xmlStartTagHook
                                "
                                " EXAMPLE:
                                "
                                " <tag id="whoops">
                                " s^^^^^^^^^^^^^^^e
                                "
                                syn region   xmlTag
                            	\ matchgroup=xmlTag start=+<[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contained
                            	\ contains=xmlError,xmlTagName,xmlAttrib,xmlEqual,xmlString,@xmlStartTagHook
                            
                            
                                " highlight the end tag
                                "
                                " PROVIDES: @xmlTagHook
                                " (should we provide a separate @xmlEndTagHook ?)
                                "
                                " EXAMPLE:
                                "
                                " </tag>
                                " ^^^^^^
                                "
                                syn region   xmlEndTag
                            	\ matchgroup=xmlTag start=+</[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contained
                            	\ contains=xmlTagName,xmlNamespace,xmlAttribPunct,@xmlTagHook
                            
                                " tag elements with syntax-folding.
                                " NOTE: NO HIGHLIGHTING -- highlighting is done by contained elements
                                "
                                " PROVIDES: @xmlRegionHook
                                "
                                " EXAMPLE:
                                "
                                " <tag id="whoops">
                                "   <!-- comment -->
                                "   <another.tag></another.tag>
                                "   <empty.tag/>
                                "   some data
                                " </tag>
                                "
                                syn region   xmlRegion
                            	\ start=+<\z([^ /!?<>"']\+\)+
                            	\ skip=+<!--\_.\{-}-->+
                            	\ end=+</\z1\_\s\{-}>+
                            	\ end=+/>+
                            	\ fold
                            	\ contains=xmlTag,xmlEndTag,xmlCdata,xmlRegion,xmlComment,xmlEntity,xmlProcessing,@xmlRegionHook,@Spell
                            	\ keepend
                            	\ extend
                            
    1              0.000001 else
                            
                                " no syntax folding:
                                " - contained attribute removed
                                " - xmlRegion not defined
                                "
    1              0.000011     syn region   xmlTag
                            	\ matchgroup=xmlTag start=+<[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contains=xmlError,xmlTagName,xmlAttrib,xmlEqual,xmlString,@xmlStartTagHook
                            
    1              0.000009     syn region   xmlEndTag
                            	\ matchgroup=xmlTag start=+</[^ /!?<>"']\@=+
                            	\ matchgroup=xmlTag end=+>+
                            	\ contains=xmlTagName,xmlNamespace,xmlAttribPunct,@xmlTagHook
                            
    1              0.000001 endif
                            
                            
                            " &entities; compare with dtd
    1              0.000005 syn match   xmlEntity                 "&[^; \t]*;" contains=xmlEntityPunct
    1              0.000003 syn match   xmlEntityPunct  contained "[&.;]"
                            
    1              0.000004 if exists('g:xml_syntax_folding')
                            
                                " The real comments (this implements the comments as defined by xml,
                                " but not all xml pages actually conform to it. Errors are flagged.
                                syn region  xmlComment
                            	\ start=+<!+
                            	\ end=+>+
                            	\ contains=xmlCommentStart,xmlCommentError
                            	\ extend
                            	\ fold
                            
    1              0.000001 else
                            
                                " no syntax folding:
                                " - fold attribute removed
                                "
    1              0.000006     syn region  xmlComment
                            	\ start=+<!+
                            	\ end=+>+
                            	\ contains=xmlCommentStart,xmlCommentError
                            	\ extend
                            
    1              0.000001 endif
                            
    1              0.000004 syn match xmlCommentStart   contained "<!" nextgroup=xmlCommentPart
    1              0.000003 syn keyword xmlTodo         contained TODO FIXME XXX
    1              0.000003 syn match   xmlCommentError contained "[^><!]"
    1              0.000009 syn region  xmlCommentPart
                                \ start=+--+
                                \ end=+--+
                                \ contained
                                \ contains=xmlTodo,@xmlCommentHook,@Spell
                            
                            
                            " CData sections
                            "
                            " PROVIDES: @xmlCdataHook
                            "
    1              0.000010 syn region    xmlCdata
                                \ start=+<!\[CDATA\[+
                                \ end=+]]>+
                                \ contains=xmlCdataStart,xmlCdataEnd,@xmlCdataHook,@Spell
                                \ keepend
                                \ extend
                            
                            " using the following line instead leads to corrupt folding at CDATA regions
                            " syn match    xmlCdata      +<!\[CDATA\[\_.\{-}]]>+  contains=xmlCdataStart,xmlCdataEnd,@xmlCdataHook
    1              0.000004 syn match    xmlCdataStart +<!\[CDATA\[+  contained contains=xmlCdataCdata
    1              0.000002 syn keyword  xmlCdataCdata CDATA          contained
    1              0.000002 syn match    xmlCdataEnd   +]]>+          contained
                            
                            
                            " Processing instructions
                            " This allows "?>" inside strings -- good idea?
    1              0.000008 syn region  xmlProcessing matchgroup=xmlProcessingDelim start="<?" end="?>" contains=xmlAttrib,xmlEqual,xmlString
                            
                            
    1              0.000003 if exists('g:xml_syntax_folding')
                            
                                " DTD -- we use dtd.vim here
                                syn region  xmlDocType matchgroup=xmlDocTypeDecl
                            	\ start="<!DOCTYPE"he=s+2,rs=s+2 end=">"
                            	\ fold
                            	\ contains=xmlDocTypeKeyword,xmlInlineDTD,xmlString
    1              0.000001 else
                            
                                " no syntax folding:
                                " - fold attribute removed
                                "
    1              0.000008     syn region  xmlDocType matchgroup=xmlDocTypeDecl
                            	\ start="<!DOCTYPE"he=s+2,rs=s+2 end=">"
                            	\ contains=xmlDocTypeKeyword,xmlInlineDTD,xmlString
                            
    1              0.000001 endif
                            
    1              0.000003 syn keyword xmlDocTypeKeyword contained DOCTYPE PUBLIC SYSTEM
    1              0.000008 syn region  xmlInlineDTD contained matchgroup=xmlDocTypeDecl start="\[" end="]" contains=@xmlDTD
    1   0.004559   0.000060 syn include @xmlDTD <sfile>:p:h/dtd.vim
    1              0.000002 unlet b:current_syntax
                            
                            
                            " synchronizing
                            
    1              0.000011 syn sync match xmlSyncComment grouphere xmlComment +<!--+
    1              0.000005 syn sync match xmlSyncComment groupthere NONE +-->+
                            
                            " The following is slow on large documents (and the doctype is optional
                            " syn sync match xmlSyncDT grouphere  xmlDocType +\_.\(<!DOCTYPE\)\@=+
                            " syn sync match xmlSyncDT groupthere  NONE       +]>+
                            
    1              0.000008 if exists('g:xml_syntax_folding')
                                syn sync match xmlSync grouphere   xmlRegion  +\_.\(<[^ /!?<>"']\+\)\@=+
                                " syn sync match xmlSync grouphere  xmlRegion "<[^ /!?<>"']*>"
                                syn sync match xmlSync groupthere  xmlRegion  +</[^ /!?<>"']\+>+
    1              0.000001 endif
                            
    1              0.000002 syn sync minlines=100 maxlines=200
                            
                            
                            " The default highlighting.
    1              0.000002 hi def link xmlTodo		Todo
    1              0.000002 hi def link xmlTag		Function
    1              0.000001 hi def link xmlTagName		Function
    1              0.000001 hi def link xmlEndTag		Identifier
    1              0.000003 if !exists("g:xml_namespace_transparent")
    1              0.000002     hi def link xmlNamespace	Tag
    1              0.000001 endif
    1              0.000001 hi def link xmlEntity		Statement
    1              0.000001 hi def link xmlEntityPunct	Type
                            
    1              0.000001 hi def link xmlAttribPunct	Comment
    1              0.000001 hi def link xmlAttrib		Type
                            
    1              0.000001 hi def link xmlString		String
    1              0.000001 hi def link xmlComment		Comment
    1              0.000001 hi def link xmlCommentStart	xmlComment
    1              0.000001 hi def link xmlCommentPart	Comment
    1              0.000001 hi def link xmlCommentError	Error
    1              0.000001 hi def link xmlError		Error
                            
    1              0.000002 hi def link xmlProcessingDelim	Comment
    1              0.000001 hi def link xmlProcessing	Type
                            
    1              0.000001 hi def link xmlCdata		String
    1              0.000001 hi def link xmlCdataCdata	Statement
    1              0.000001 hi def link xmlCdataStart	Type
    1              0.000001 hi def link xmlCdataEnd		Type
                            
    1              0.000001 hi def link xmlDocTypeDecl	Function
    1              0.000001 hi def link xmlDocTypeKeyword	Statement
    1              0.000001 hi def link xmlInlineDTD	Function
                            
    1              0.000003 let b:current_syntax = "xml"
                            
    1   0.000037   0.000015 let &cpo = s:xml_cpo_save
    1              0.000003 unlet s:xml_cpo_save
                            
                            " vim: ts=4

SCRIPT  /usr/share/nvim/runtime/syntax/dtd.vim
Sourced 1 time
Total time:   0.004494
 Self time:   0.004432

count  total (s)   self (s)
                            " Vim syntax file
                            " Language: DTD (Document Type Definition for XML)
                            " Maintainer: Christian Brabandt <cb@256bit.org>
                            " Repository: https://github.com/chrisbra/vim-xml-ftplugin
                            " Previous Maintainer: Johannes Zellner <johannes@zellner.org>
                            " Author: Daniel Amyot <damyot@site.uottawa.ca>
                            " Last Changed:	Sept 24, 2019
                            " Filenames: *.dtd
                            "
                            " REFERENCES:
                            "   http://www.w3.org/TR/html40/
                            "   http://www.w3.org/TR/NOTE-html-970421
                            "
                            " TODO:
                            "   - improve synchronizing.
                            
    1              0.000006 if exists("b:current_syntax")
                                finish
    1              0.000001 endif
    1              0.000009 let s:dtd_cpo_save = &cpo
    1   0.000044   0.000012 set cpo&vim
                            
    1              0.000004 if !exists("dtd_ignore_case")
                                " I prefer having the case takes into consideration.
    1              0.000002     syn case match
                            else
                                syn case ignore
    1              0.000001 endif
                            
                            
                            " the following line makes the opening <! and
                            " closing > highlighted using 'dtdFunction'.
                            "
                            " PROVIDES: @dtdTagHook
                            "
    1              0.000018 syn region dtdTag matchgroup=dtdFunction
                                \ start=+<!+ end=+>+ matchgroup=NONE
                                \ contains=dtdTag,dtdTagName,dtdError,dtdComment,dtdString,dtdAttrType,dtdAttrDef,dtdEnum,dtdParamEntityInst,dtdParamEntityDecl,dtdCard,@dtdTagHook
                            
    1              0.000003 if !exists("dtd_no_tag_errors")
                                " mark everything as an error which starts with a <!
                                " and is not overridden later. If this is annoying,
                                " it can be switched off by setting the variable
                                " dtd_no_tag_errors.
    1              0.000005     syn region dtdError contained start=+<!+lc=2 end=+>+
    1              0.000001 endif
                            
                            " if this is a html like comment highlight also
                            " the opening <! and the closing > as Comment.
    1              0.000009 syn region dtdComment		start=+<![ \t]*--+ end=+-->+ contains=dtdTodo,@Spell
                            
                            
                            " proper DTD comment
    1              0.000006 syn region dtdComment contained start=+--+ end=+--+ contains=dtdTodo,@Spell
                            
                            
                            " Start tags (keywords). This is contained in dtdFunction.
                            " Note that everything not contained here will be marked
                            " as error.
    1              0.000010 syn match dtdTagName contained +<!\(ATTLIST\|DOCTYPE\|ELEMENT\|ENTITY\|NOTATION\|SHORTREF\|USEMAP\|\[\)+lc=2,hs=s+2
                            
                            
                            " wildcards and operators
    1              0.000003 syn match  dtdCard contained "|"
    1              0.000002 syn match  dtdCard contained ","
                            " evenutally overridden by dtdEntity
    1              0.000002 syn match  dtdCard contained "&"
    1              0.000002 syn match  dtdCard contained "?"
    1              0.000002 syn match  dtdCard contained "\*"
    1              0.000002 syn match  dtdCard contained "+"
                            
                            " ...and finally, special cases.
    1              0.000003 syn match  dtdCard      "ANY"
    1              0.000003 syn match  dtdCard      "EMPTY"
                            
    1              0.000003 if !exists("dtd_no_param_entities")
                            
                                " highlight parameter entity declarations
                                " and instances. Note that the closing `;'
                                " is optional.
                            
                                " instances
    1              0.000015     syn region dtdParamEntityInst oneline matchgroup=dtdParamEntityPunct
                            	\ start="%[-_a-zA-Z0-9.]\+"he=s+1,rs=s+1
                            	\ skip=+[-_a-zA-Z0-9.]+
                            	\ end=";\|\>"
                            	\ matchgroup=NONE contains=dtdParamEntityPunct
    1              0.000008     syn match  dtdParamEntityPunct contained "\."
                            
                                " declarations
                                " syn region dtdParamEntityDecl oneline matchgroup=dtdParamEntityDPunct start=+<!ENTITY % +lc=8 skip=+[-_a-zA-Z0-9.]+ matchgroup=NONE end="\>" contains=dtdParamEntityDPunct
    1              0.000007     syn match dtdParamEntityDecl +<!ENTITY % [-_a-zA-Z0-9.]*+lc=8 contains=dtdParamEntityDPunct
    1              0.000003     syn match  dtdParamEntityDPunct contained "%\|\."
                            
    1              0.000001 endif
                            
                            " &entities; compare with xml
    1              0.000005 syn match   dtdEntity		      "&[^; \t]*;" contains=dtdEntityPunct
    1              0.000003 syn match   dtdEntityPunct  contained "[&.;]"
                            
                            " Strings are between quotes
    1              0.000010 syn region dtdString    start=+"+ skip=+\\\\\|\\"+  end=+"+ contains=dtdAttrDef,dtdAttrType,dtdParamEntityInst,dtdEntity,dtdCard
    1              0.000009 syn region dtdString    start=+'+ skip=+\\\\\|\\'+  end=+'+ contains=dtdAttrDef,dtdAttrType,dtdParamEntityInst,dtdEntity,dtdCard
                            
                            " Enumeration of elements or data between parenthesis
                            "
                            " PROVIDES: @dtdEnumHook
                            "
    1              0.000008 syn region dtdEnum matchgroup=dtdType start="(" end=")" matchgroup=NONE contains=dtdEnum,dtdParamEntityInst,dtdCard,@dtdEnumHook
                            
                            "Attribute types
    1              0.000004 syn keyword dtdAttrType NMTOKEN  ENTITIES  NMTOKENS  ID  CDATA
    1              0.000002 syn keyword dtdAttrType IDREF  IDREFS
                            " ENTITY has to treated special for not overriding <!ENTITY
    1              0.000004 syn match   dtdAttrType +[^!]\<ENTITY+
                            
                            "Attribute Definitions
    1              0.000004 syn match  dtdAttrDef   "#REQUIRED"
    1              0.000003 syn match  dtdAttrDef   "#IMPLIED"
    1              0.000003 syn match  dtdAttrDef   "#FIXED"
                            
    1              0.000001 syn case match
                            " define some common keywords to mark TODO
                            " and important sections inside comments.
    1              0.000003 syn keyword dtdTodo contained TODO FIXME XXX
                            
    1              0.000002 syn sync lines=250
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
                            " The default highlighting.
    1              0.000006 hi def link dtdFunction		Function
    1              0.000002 hi def link dtdTag		Normal
    1              0.000002 hi def link dtdType		Type
    1              0.000001 hi def link dtdAttrType		dtdType
    1              0.000001 hi def link dtdAttrDef		dtdType
    1              0.000001 hi def link dtdConstant		Constant
    1              0.000001 hi def link dtdString		dtdConstant
    1              0.000001 hi def link dtdEnum		dtdConstant
    1              0.000001 hi def link dtdCard		dtdFunction
                            
    1              0.000001 hi def link dtdEntity		Statement
    1              0.000001 hi def link dtdEntityPunct	dtdType
    1              0.000001 hi def link dtdParamEntityInst	dtdConstant
    1              0.000001 hi def link dtdParamEntityPunct	dtdType
    1              0.000001 hi def link dtdParamEntityDecl	dtdType
    1              0.000001 hi def link dtdParamEntityDPunct dtdComment
                            
    1              0.000001 hi def link dtdComment		Comment
    1              0.000001 hi def link dtdTagName		Statement
    1              0.000002 hi def link dtdError		Error
    1              0.000001 hi def link dtdTodo		Todo
                            
                            
    1   0.000051   0.000021 let &cpo = s:dtd_cpo_save
    1              0.000004 unlet s:dtd_cpo_save
                            
    1              0.000003 let b:current_syntax = "dtd"
                            
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/javascript.vim
Sourced 1 time
Total time:   0.001118
 Self time:   0.001062

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2022 Jun 09
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    1              0.000006 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
    1              0.000005 elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
    1              0.000001 endif
                            
    1              0.000009 let s:cpo_save = &cpo
    1   0.000046   0.000014 set cpo&vim
                            
                            
    1              0.000006 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
    1              0.000009 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
    1              0.000008 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
    1              0.000009 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
    1              0.000005 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
    1              0.000010 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
    1              0.000009 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
    1              0.000009 syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
    1              0.000006 syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
                            " number handling by Christopher Leonard chris.j.leonard@gmx.com
    1              0.000004 syn match   javaScriptSpecialCharacter "'\\.'"
    1              0.000007 syn match   javaScriptNumber           "\<0[bB][0-1]\+\(_[0-1]\+\)*\>"
    1              0.000005 syn match   javaScriptNumber           "\<0[oO][0-7]\+\(_[0-7]\+\)*\>"
    1              0.000005 syn match   javaScriptNumber           "\<0\([0-7]\+\(_[0-7]\+\)*\)\?\>"
    1              0.000005 syn match   javaScriptNumber           "\<0[xX][0-9a-fA-F]\+\(_[0-9a-fA-F]\+\)*\>"
    1              0.000005 syn match   javaScriptNumber           "\<\d\+\(_\d\+\)*[eE][+-]\?\d\+\>"
    1              0.000008 syn match   javaScriptNumber           "\<[1-9]\d*\(_\d\+\)*\(\.\(\d\+\(_\d\+\)*\([eE][+-]\?\d\+\)\?\)\?\)\?\>"
    1              0.000007 syn match   javaScriptNumber           "\<\(\d\+\(_\d\+\)*\)\?\.\d\+\(_\d\+\)*\([eE][+-]\?\d\+\)\?\>"
    1              0.000006 syn match   javaScriptNumber           "\<\d\+\(_\d\+\)*\.\(\d\+\(_\d\+\)*\([eE][+-]\?\d\+\)\?\)\?\>"
    1              0.000023 syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
    1              0.000004 syn keyword javaScriptConditional	if else switch
    1              0.000004 syn keyword javaScriptRepeat		while for do in
    1              0.000003 syn keyword javaScriptBranch		break continue
    1              0.000004 syn keyword javaScriptOperator		new delete instanceof typeof
    1              0.000005 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
    1              0.000003 syn keyword javaScriptStatement		return with await
    1              0.000003 syn keyword javaScriptBoolean		true false
    1              0.000003 syn keyword javaScriptNull		null undefined
    1              0.000004 syn keyword javaScriptIdentifier	arguments this var let
    1              0.000003 syn keyword javaScriptLabel		case default
    1              0.000004 syn keyword javaScriptException		try catch finally throw
    1              0.000004 syn keyword javaScriptMessage		alert confirm prompt status
    1              0.000003 syn keyword javaScriptGlobal		self window top parent
    1              0.000004 syn keyword javaScriptMember		document event location 
    1              0.000004 syn keyword javaScriptDeprecated	escape unescape
    1              0.000014 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile async
                            
    1              0.000006 syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
    1              0.000008 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
    1              0.000001 else
    1              0.000003     syn keyword javaScriptFunction	function
    1              0.000004     syn match	javaScriptBraces	   "[{}\[\]]"
    1              0.000003     syn match	javaScriptParens	   "[()]"
    1              0.000001 endif
                            
    1              0.000003 if main_syntax == "javascript"
                              syn sync fromstart
                              syn sync maxlines=100
                            
                              syn sync ccomment javaScriptComment
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
    1              0.000003 hi def link javaScriptComment		Comment
    1              0.000002 hi def link javaScriptLineComment		Comment
    1              0.000002 hi def link javaScriptCommentTodo		Todo
    1              0.000002 hi def link javaScriptSpecial		Special
    1              0.000002 hi def link javaScriptStringS		String
    1              0.000001 hi def link javaScriptStringD		String
    1              0.000001 hi def link javaScriptStringT		String
    1              0.000002 hi def link javaScriptCharacter		Character
    1              0.000002 hi def link javaScriptSpecialCharacter	javaScriptSpecial
    1              0.000002 hi def link javaScriptNumber		javaScriptValue
    1              0.000002 hi def link javaScriptConditional		Conditional
    1              0.000001 hi def link javaScriptRepeat		Repeat
    1              0.000001 hi def link javaScriptBranch		Conditional
    1              0.000001 hi def link javaScriptOperator		Operator
    1              0.000001 hi def link javaScriptType			Type
    1              0.000002 hi def link javaScriptStatement		Statement
    1              0.000001 hi def link javaScriptFunction		Function
    1              0.000001 hi def link javaScriptBraces		Function
    1              0.000002 hi def link javaScriptError		Error
    1              0.000001 hi def link javaScrParenError		javaScriptError
    1              0.000001 hi def link javaScriptNull			Keyword
    1              0.000001 hi def link javaScriptBoolean		Boolean
    1              0.000001 hi def link javaScriptRegexpString		String
                            
    1              0.000001 hi def link javaScriptIdentifier		Identifier
    1              0.000001 hi def link javaScriptLabel		Label
    1              0.000001 hi def link javaScriptException		Exception
    1              0.000001 hi def link javaScriptMessage		Keyword
    1              0.000001 hi def link javaScriptGlobal		Keyword
    1              0.000001 hi def link javaScriptMember		Keyword
    1              0.000001 hi def link javaScriptDeprecated		Exception 
    1              0.000001 hi def link javaScriptReserved		Keyword
    1              0.000001 hi def link javaScriptDebug		Debug
    1              0.000001 hi def link javaScriptConstant		Label
    1              0.000001 hi def link javaScriptEmbed		Special
                            
                            
                            
    1              0.000003 let b:current_syntax = "javascript"
    1              0.000002 if main_syntax == 'javascript'
                              unlet main_syntax
    1              0.000001 endif
    1   0.000040   0.000016 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/vb.vim
Sourced 1 time
Total time:   0.003788
 Self time:   0.003788

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Visual Basic
                            " Maintainer:   Doug Kearns <dougkearns@gmail.com>
                            " Former Maintainer:    Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:    Robert M. Cortopassi <cortopar@mindspring.com>
                            "       (tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2021 Nov 26  Incorporated additions from Doug Kearns
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " quit when a syntax file was already loaded
    1              0.000016 if exists("b:current_syntax")
                                    finish
    1              0.000001 endif
                            
                            " VB is case insensitive
    1              0.000017 syn case ignore
                            
    1              0.000008 syn keyword vbConditional If Then ElseIf Else Select Case
                            
    1              0.000006 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
    1              0.000005 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
    1              0.000007 syn match vbOperator "[()+.,\-/*=&]"
    1              0.000004 syn match vbOperator "[<>]=\="
    1              0.000003 syn match vbOperator "<>"
    1              0.000004 syn match vbOperator "\s\+_$"
                            
    1              0.000003 syn keyword vbBoolean  True False
    1              0.000003 syn keyword vbConst Null Nothing
                            
    1              0.000004 syn keyword vbRepeat Do For ForEach Loop Next
    1              0.000003 syn keyword vbRepeat Step To Until Wend While
                            
    1              0.000003 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
    1              0.000003 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
    1              0.000003 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
    1              0.000003 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
    1              0.000003 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
    1              0.000003 syn keyword vbEvents ApplyChanges Associate AsyncProgress
    1              0.000003 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
    1              0.000002 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
    1              0.000003 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
    1              0.000003 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
    1              0.000003 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
    1              0.000002 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
    1              0.000003 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
    1              0.000002 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
    1              0.000003 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
    1              0.000003 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
    1              0.000003 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
    1              0.000004 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
    1              0.000003 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
    1              0.000003 syn keyword vbEvents ConfigChageCancelled ConfigChanged
    1              0.000003 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
    1              0.000003 syn keyword vbEvents CurrentRecordChanged DECommandAdded
    1              0.000003 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
    1              0.000003 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
    1              0.000003 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
    1              0.000003 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
    1              0.000003 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
    1              0.000003 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
    1              0.000003 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
    1              0.000003 syn keyword vbEvents Disconnect DisplayChanged Dissociate
    1              0.000003 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
    1              0.000003 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
    1              0.000004 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
    1              0.000003 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
    1              0.000003 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
    1              0.000003 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
    1              0.000003 syn keyword vbEvents IniProperties InitProperties Initialize
    1              0.000003 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
    1              0.000003 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
    1              0.000003 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
    1              0.000003 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
    1              0.000003 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
    1              0.000003 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
    1              0.000049 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
    1              0.000004 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
    1              0.000003 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
    1              0.000004 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
    1              0.000003 syn keyword vbEvents PatternChange PlotActivated PlotSelected
    1              0.000003 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
    1              0.000003 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
    1              0.000003 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
    1              0.000003 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
    1              0.000003 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
    1              0.000003 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
    1              0.000003 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
    1              0.000002 syn keyword vbEvents RepeatedControlUnloaded Reposition
    1              0.000003 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
    1              0.000003 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
    1              0.000003 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
    1              0.000004 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
    1              0.000003 syn keyword vbEvents SendComplete SendProgress SeriesActivated
    1              0.000004 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
    1              0.000006 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
    1              0.000006 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
    1              0.000003 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
    1              0.000003 syn keyword vbEvents UnboundAddData UnboundDeleteRow
    1              0.000003 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
    1              0.000003 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
    1              0.000003 syn keyword vbEvents UserEvent Validate ValidationError
    1              0.000003 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
    1              0.000003 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
    1              0.000002 syn keyword vbEvents WriteProperties
                            
                            
    1              0.000006 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
    1              0.000005 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
    1              0.000004 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
    1              0.000005 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
    1              0.000004 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
    1              0.000004 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
    1              0.000004 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
    1              0.000003 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
    1              0.000003 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
    1              0.000017 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
    1              0.000004 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
    1              0.000004 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
    1              0.000003 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
    1              0.000004 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
    1              0.000003 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
    1              0.000004 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
    1              0.000004 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
    1              0.000004 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
    1              0.000005 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
    1              0.000004 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
    1              0.000004 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
    1              0.000004 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
    1              0.000004 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
    1              0.000002 syn keyword vbFunction Year
                            
    1              0.000004 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
    1              0.000003 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
    1              0.000003 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
    1              0.000003 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
    1              0.000003 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
    1              0.000003 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
    1              0.000003 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
    1              0.000003 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
    1              0.000004 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
    1              0.000007 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
    1              0.000004 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
    1              0.000004 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
    1              0.000003 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
    1              0.000003 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
    1              0.000003 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
    1              0.000003 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
    1              0.000003 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
    1              0.000003 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
    1              0.000003 syn keyword vbMethods CreateWorkspace Customize Cut Delete
    1              0.000003 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
    1              0.000003 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
    1              0.000004 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
    1              0.000004 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
    1              0.000003 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
    1              0.000004 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
    1              0.000004 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
    1              0.000003 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
    1              0.000003 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
    1              0.000003 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
    1              0.000004 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
    1              0.000003 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
    1              0.000003 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
    1              0.000003 syn keyword vbMethods GetRows GetSelectedPart GetSelection
    1              0.000003 syn keyword vbMethods GetSpecialFolder GetTempName GetText
    1              0.000004 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
    1              0.000004 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
    1              0.000003 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
    1              0.000003 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
    1              0.000004 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
    1              0.000003 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
    1              0.000003 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
    1              0.000003 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
    1              0.000003 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
    1              0.000003 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
    1              0.000003 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
    1              0.000004 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
    1              0.000003 syn keyword vbMethods OnDisconnection OnStartupComplete Open
    1              0.000003 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
    1              0.000003 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
    1              0.000003 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
    1              0.000003 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
    1              0.000003 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
    1              0.000003 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
    1              0.000003 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
    1              0.000003 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
    1              0.000003 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
    1              0.000003 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
    1              0.000003 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
    1              0.000003 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
    1              0.000003 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
    1              0.000003 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
    1              0.000003 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
    1              0.000004 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
    1              0.000004 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
    1              0.000004 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
    1              0.000003 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
    1              0.000003 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
    1              0.000004 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
    1              0.000003 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
    1              0.000004 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
    1              0.000005 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
    1              0.000003 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
    1              0.000004 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
    1              0.000003 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
    1              0.000003 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
    1              0.000003 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
    1              0.000005 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
    1              0.000005 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
    1              0.000004 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
    1              0.000004 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
    1              0.000005 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
    1              0.000004 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
    1              0.000004 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
    1              0.000005 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
    1              0.000004 syn keyword vbStatement Option Preserve Private Property Public Put RSet
    1              0.000003 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
    1              0.000004 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
    1              0.000004 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
    1              0.000004 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
    1              0.000002 syn keyword vbStatement Write
                            
    1              0.000005 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
    1              0.000005 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
    1              0.000004 syn keyword vbKeyword Option Optional ParamArray Print Private Property
    1              0.000003 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
    1              0.000004 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
    1              0.000004 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
    1              0.000002 syn keyword vbTodo contained    TODO
                            
                            "Datatypes
    1              0.000005 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
    1              0.000004 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
    1              0.000004 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
    1              0.000004 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
    1              0.000004 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
    1              0.000004 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
    1              0.000002 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
    1              0.000003 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
    1              0.000003 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
    1              0.000003 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
    1              0.000003 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
    1              0.000003 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
    1              0.000003 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
    1              0.000003 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
    1              0.000003 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
    1              0.000003 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
    1              0.000003 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
    1              0.000003 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
    1              0.000003 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
    1              0.000003 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
    1              0.000003 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
    1              0.000003 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
    1              0.000003 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
    1              0.000003 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
    1              0.000003 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
    1              0.000003 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
    1              0.000003 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
    1              0.000003 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
    1              0.000003 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
    1              0.000003 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
    1              0.000003 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
    1              0.000003 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
    1              0.000003 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
    1              0.000003 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
    1              0.000005 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
    1              0.000003 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
    1              0.000003 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
    1              0.000003 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
    1              0.000003 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
    1              0.000004 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
    1              0.000004 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
    1              0.000003 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
    1              0.000003 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
    1              0.000003 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
    1              0.000003 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
    1              0.000003 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
    1              0.000003 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
    1              0.000003 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
    1              0.000003 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
    1              0.000003 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
    1              0.000003 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
    1              0.000003 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
    1              0.000003 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
    1              0.000003 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
    1              0.000004 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
    1              0.000003 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
    1              0.000003 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
    1              0.000003 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
    1              0.000003 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
    1              0.000003 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
    1              0.000003 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
    1              0.000011 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
    1              0.000003 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
    1              0.000003 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
    1              0.000003 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
    1              0.000003 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
    1              0.000003 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
    1              0.000003 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
    1              0.000003 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
    1              0.000003 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
    1              0.000003 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
    1              0.000005 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
    1              0.000004 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
    1              0.000003 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber            "{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber            ":[[:xdigit:]]\+"
                            "syn match  vbNumber            "[-+]\=\<\d\+\>"
    1              0.000011 syn match  vbFloat              "[-+]\=\<\d\+[eE][\-+]\=\d\+"
    1              0.000006 syn match  vbFloat              "[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
    1              0.000005 syn match  vbFloat              "[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character constants
    1              0.000007 syn region  vbString		start=+"+  end=+"\|$+
    1              0.000008 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
    1              0.000006 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
    1              0.000004 syn match   vbLineLabel		"^\h\w\+:"
    1              0.000004 syn match   vbLineNumber	"^\d\+\(:\|\s\|$\)"
    1              0.000005 syn match   vbTypeSpecifier  "\<\a\w*[@\$%&!#]"ms=s+1
    1              0.000004 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            " Conditional Compilation
    1              0.000004 syn match  vbPreProc "^#const\>"
    1              0.000010 syn region vbPreProc matchgroup=PreProc start="^#if\>"     end="\<then\>" transparent contains=TOP
    1              0.000007 syn region vbPreProc matchgroup=PreProc start="^#elseif\>" end="\<then\>" transparent contains=TOP
    1              0.000003 syn match  vbPreProc "^#else\>"
    1              0.000004 syn match  vbPreProc "^#end\s*if\>"
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000003 hi def link vbBoolean           Boolean
    1              0.000002 hi def link vbLineNumber        Comment
    1              0.000002 hi def link vbLineLabel         Comment
    1              0.000001 hi def link vbComment           Comment
    1              0.000002 hi def link vbConditional       Conditional
    1              0.000001 hi def link vbConst             Constant
    1              0.000003 hi def link vbDefine            Constant
    1              0.000001 hi def link vbError             Error
    1              0.000001 hi def link vbFunction          Identifier
    1              0.000001 hi def link vbIdentifier        Identifier
    1              0.000001 hi def link vbNumber            Number
    1              0.000001 hi def link vbFloat             Float
    1              0.000001 hi def link vbMethods           PreProc
    1              0.000001 hi def link vbOperator          Operator
    1              0.000001 hi def link vbRepeat            Repeat
    1              0.000001 hi def link vbString            String
    1              0.000001 hi def link vbStatement         Statement
    1              0.000001 hi def link vbKeyword           Statement
    1              0.000001 hi def link vbEvents            Special
    1              0.000001 hi def link vbTodo              Todo
    1              0.000001 hi def link vbTypes             Type
    1              0.000001 hi def link vbTypeSpecifier     Type
    1              0.000001 hi def link vbPreProc           PreProc
                            
    1              0.000005 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/css.vim
Sourced 1 time
Total time:   0.018370
 Self time:   0.018277

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Jules Wang      <w.jq0722@gmail.com>
                            "               Claudio Fleiner <claudio@fleiner.com>
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/vim-language-dept/css-syntax.vim
                            " Maintainer:   Jay Sitter <jay@jaysitter.com>
                            " Last Change:  2021 Oct 20
                            
                            " quit when a syntax file was already loaded
    1              0.000011 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
    1              0.000005 elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
    1              0.000001 endif
                            
    1              0.000012 let s:cpo_save = &cpo
    1   0.000065   0.000017 set cpo&vim
                            
    1              0.000002 syn case ignore
                            " Add dash to allowed keyword characters.
    1              0.000011 syn iskeyword @,48-57,_,192-255,-
                            
                            " HTML4 tags
    1              0.000007 syn keyword cssTagName abbr address area a b base
    1              0.000005 syn keyword cssTagName bdo blockquote body br button
    1              0.000005 syn keyword cssTagName caption cite code col colgroup dd del
    1              0.000004 syn keyword cssTagName dfn div dl dt em fieldset form
    1              0.000005 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    1              0.000005 syn keyword cssTagName iframe input ins isindex kbd label legend li
    1              0.000005 syn keyword cssTagName link map menu meta noscript ol optgroup
    1              0.000005 syn keyword cssTagName option p param picture pre q s samp script small
    1              0.000004 syn keyword cssTagName span strong sub sup tbody td
    1              0.000005 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    1              0.000002 syn keyword cssTagName object svg
    1              0.000011 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    1              0.000005 syn keyword cssTagName article aside audio bdi canvas command data
    1              0.000005 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    1              0.000004 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    1              0.000004 syn keyword cssTagName output progress rt rp ruby section
    1              0.000004 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    1              0.000004 syn match cssTagName "\*"
                            
                            " selectors
    1              0.000005 syn match cssSelectorOp "[,>+~]"
    1              0.000005 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    1              0.000012 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    1              0.000008 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    1              0.000003 syn match cssClassNameDot contained '\.'
                            
    1              0.000002 try
    1              0.000007 syn match cssIdentifier "#[A-Za-z-_@][A-Za-z-0-9_@-]*"
                            catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
    1              0.000002 endtry
                            
                            " digits
    1              0.000006 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    1              0.000006 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    1              0.000016 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\|fr\|vw\|vh\|vmin\|vmax\|ch\)\>" contains=cssUnitDecorators
    1              0.000005 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
    1              0.000007 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    1              0.000006 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    1              0.000007 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
    1              0.000009 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    1              0.000003 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    1              0.000004 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    1              0.000006 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    1              0.000010 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    1              0.000009 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    1              0.000005 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    1              0.000005 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    1              0.000039 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    1              0.000004 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    1              0.000004 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    1              0.000004 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    1              0.000003 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    1              0.000011 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    1              0.000008 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    1              0.000006 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    1              0.000009 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    1              0.000009 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    1              0.000004 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    1              0.000004 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    1              0.000010 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    1              0.000004 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    1              0.000004 syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
    1              0.000004 syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
    1              0.000004 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    1              0.000003 syn keyword cssColor contained thistle tomato turquoise violet wheat
    1              0.000002 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    1              0.000002 syn case match
    1              0.000011 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    1              0.000001 syn case ignore
                            
    1              0.000004 syn match cssImportant contained "!\s*important\>"
    1              0.000007 syn match cssCustomProp contained "\<--[a-zA-Z0-9-_]*\>"
                            
    1              0.000004 syn match cssColor contained "\<transparent\>"
    1              0.000004 syn match cssColor contained "\<currentColor\>"
    1              0.000004 syn match cssColor contained "\<white\>"
    1              0.000008 syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
    1              0.000006 syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
    1              0.000004 syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
    1              0.000013 syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    1              0.001004 syn region cssMathGroup contained matchgroup=cssMathParens start="(" end=")" containedin=cssFunction,cssMathGroup contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
    1              0.001004 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(var\|calc\)\s*(" end=")" contains=cssCustomProp,cssValue.*,cssFunction,cssColor,cssStringQ,cssStringQQ oneline
    1              0.000024 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    1              0.000014 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    1              0.000016 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\|conic-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    1              0.000034 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    1              0.000021 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(blur\|brightness\|contrast\|drop-shadow\|grayscale\|hue-rotate\|invert\|opacity\|saturate\|sepia\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    1              0.000009 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    1              0.000004 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    1              0.000006 syn keyword cssCommonAttr contained auto none inherit all default normal
    1              0.000004 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
    1              0.000009 syn match cssCommonAttr contained "\<\(max-\|min-\|fit-\)content\>"
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    1              0.000016 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    1              0.000003 syn keyword cssAnimationAttr contained alternate reverse
    1              0.000007 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    1              0.000003 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    1              0.000003 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    1              0.000002 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    1              0.000010 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    1              0.000003 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    1              0.000004 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    1              0.000059 syn match cssBackgroundAttr contained "\<no-repeat\>"
    1              0.000032 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
    1              0.000004 syn keyword cssBackgroundAttr contained cover contain
                            
    1              0.000010 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    1              0.000008 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    1              0.000009 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    1              0.000005 syn match cssBorderProp contained "\<box-decoration-break\>"
    1              0.000004 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    1              0.000004 syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
    1              0.000006 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    1              0.000003 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    1              0.000002 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    1              0.000007 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000006 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    1              0.000014 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    1              0.000005 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    1              0.000004 syn keyword cssBoxAttr contained visible hidden scroll auto
    1              0.000005 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    1              0.000002 syn keyword cssCascadeProp contained all
    1              0.000003 syn keyword cssCascadeAttr contained initial unset revert
                            
    1              0.000002 syn keyword cssColorProp contained opacity
    1              0.000004 syn match cssColorProp contained "\<color-profile\>"
    1              0.000004 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    1              0.000005 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    1              0.000002 syn keyword cssDimensionProp contained height
    1              0.000002 syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
    1              0.000007 syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
    1              0.000007 syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
    1              0.000002 syn keyword cssFlexibleBoxProp contained order
                            
    1              0.000012 syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
    1              0.000004 syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
    1              0.000004 syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
    1              0.000005 syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\|evenly\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    1              0.000020 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    1              0.000003 syn keyword cssFontAttr contained icon menu caption
    1              0.000004 syn match cssFontAttr contained "\<message-box\>"
    1              0.000003 syn match cssFontAttr contained "\<status-bar\>"
    1              0.000002 syn keyword cssFontAttr contained larger smaller
    1              0.000005 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
    1              0.000004 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
    1              0.000004 syn keyword cssFontAttr contained sans-serif serif cursive fantasy monospace
                            " font-feature-settings attributes
    1              0.000002 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    1              0.000007 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    1              0.000002 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    1              0.000002 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    1              0.000002 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    1              0.000004 syn match cssFontProp contained "\<font-smooth\>"
    1              0.000005 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    1              0.000006 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    1              0.000009 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    1              0.000002 syn keyword cssMultiColumnProp contained columns
    1              0.000003 syn keyword cssMultiColumnAttr contained balance medium
    1              0.000003 syn keyword cssMultiColumnAttr contained always left right page column
    1              0.000005 syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    1              0.000006 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
    1              0.000004 syn match cssInteractProp contained "\<pointer-events\>"
    1              0.000007 syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
    1              0.000004 syn keyword cssGeneratedContentProp contained quotes crop
    1              0.000005 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    1              0.000003 syn match cssGeneratedContentProp contained "\<move-to\>"
    1              0.000004 syn match cssGeneratedContentProp contained "\<page-policy\>"
    1              0.000009 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
    1              0.000003 syn match cssGridProp contained "\<grid\>"
    1              0.000006 syn match cssGridProp contained "\<grid-template\(-\(columns\|rows\|areas\)\)\=\>"
    1              0.000006 syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
    1              0.000004 syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
    1              0.000003 syn match cssGridProp contained "\<gap\>"
    1              0.000005 syn match cssGridProp contained "\<grid-auto-\(flow\|rows\|columns\)\>"
                            
    1              0.000005 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    1              0.000007 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    1              0.000008 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    1              0.000005 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    1              0.000008 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    1              0.000005 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    1              0.000002 syn keyword cssListAttr contained inside outside
                            
                            " object-fit https://www.w3.org/TR/css-images-3/#the-object-fit
    1              0.000005 syn match cssObjectProp contained "\<object-\(fit\|position\)\>"
    1              0.000004 syn keyword cssObjectAttr contained fill contain cover scale-down
                            
    1              0.000009 syn keyword cssPositioningProp contained bottom clear clip display float left
    1              0.000003 syn keyword cssPositioningProp contained position right top visibility
    1              0.000003 syn match cssPositioningProp contained "\<z-index\>"
    1              0.000003 syn keyword cssPositioningAttr contained block compact grid
    1              0.000013 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    1              0.000003 syn keyword cssPositioningAttr contained left right both
    1              0.000003 syn match cssPositioningAttr contained "\<list-item\>"
    1              0.000008 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
    1              0.000005 syn match cssPositioningAttr contained "\<flow\(-root\)\=\>"
    1              0.000005 syn keyword cssPositioningAttr contained static relative absolute fixed subgrid sticky
                            
    1              0.000004 syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
    1              0.000009 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    1              0.000005 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    1              0.000003 syn keyword cssTextProp contained color direction hyphens
    1              0.000019 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    1              0.000010 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    1              0.000007 syn match cssTextProp contained "\<\(word\|line\)-break\|\(overflow\|word\)-wrap\>"
    1              0.000003 syn match cssTextProp contained "\<white-space\>"
    1              0.000005 syn match cssTextProp contained "\<hanging-punctuation\>"
    1              0.000003 syn match cssTextProp contained "\<tab-size\>"
    1              0.000004 syn match cssTextProp contained "\<punctuation-trim\>"
    1              0.000004 syn match cssTextAttr contained "\<line-through\>"
    1              0.000007 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    1              0.000004 syn keyword cssTextAttr contained ltr rtl embed nowrap
    1              0.000005 syn keyword cssTextAttr contained underline overline blink sub super middle
    1              0.000003 syn keyword cssTextAttr contained capitalize uppercase lowercase
    1              0.000003 syn keyword cssTextAttr contained justify baseline sub super
    1              0.000003 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed geometricPrecision
    1              0.000004 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    1              0.000004 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    1              0.000004 syn keyword cssTextAttr contained start end adjacent
    1              0.000006 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    1              0.000003 syn keyword cssTextAttr contained distribute kashida first last
    1              0.000003 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    1              0.000005 syn match cssTextAttr contained "\<break-all\>"
    1              0.000003 syn match cssTextAttr contained "\<break-word\>"
    1              0.000002 syn keyword cssTextAttr contained manual
    1              0.000003 syn match cssTextAttr contained "\<bidi-override\>"
                            
    1              0.000005 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    1              0.000005 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    1              0.000004 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    1              0.000010 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    1              0.000007 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    1              0.000005 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    1              0.000004 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    1              0.000003 syn match cssUIProp contained "\<box-sizing\>"
    1              0.000007 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    1              0.000002 syn keyword cssUIProp contained cursor
    1              0.000007 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    1              0.000004 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    1              0.000004 syn keyword cssUIAttr contained progress wait text cell move
    1              0.000003 syn match cssUIAttr contained "\<context-menu\>"
    1              0.000003 syn match cssUIAttr contained "\<no-drop\>"
    1              0.000005 syn match cssUIAttr contained "\<not-allowed\>"
    1              0.000003 syn match cssUIAttr contained "\<all-scroll\>"
    1              0.000004 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    1              0.000004 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    1              0.000006 syn match cssUIProp contained "\<ime-mode\>"
    1              0.000003 syn keyword cssUIAttr contained active inactive disabled
                            
    1              0.000007 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    1              0.000007 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    1              0.000002 syn keyword cssUIAttr contained invert
                            
    1              0.000002 syn keyword cssUIProp contained icon resize
    1              0.000002 syn keyword cssUIAttr contained both horizontal vertical
                            
    1              0.000003 syn match cssUIProp contained "\<text-overflow\>"
    1              0.000002 syn keyword cssUIAttr contained clip ellipsis
                            
    1              0.000005 syn match cssUIProp contained "\<image-rendering\>"
    1              0.000002 syn keyword cssUIAttr contained pixellated
    1              0.000003 syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    1              0.000003 syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
    1              0.000003 syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
    1              0.000009 syn match cssUIProp contained '\<\(tap-highlight-color\|user-select\|touch-callout\)\>'
                            " IE specific properties
    1              0.000006 syn match cssIEUIProp contained '\<\(interpolation-mode\|zoom\|filter\)\>'
                            
                            " Webkit/Firebox specific properties/attributes
    1              0.000002 syn keyword cssUIProp contained appearance
    1              0.000004 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    1              0.000006 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    1              0.000013 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    1              0.000005 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    1              0.000006 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    1              0.000002 syn keyword cssAuralAttr contained silent
    1              0.000005 syn match cssAuralAttr contained "\<spell-out\>"
    1              0.000002 syn keyword cssAuralAttr contained non mix
    1              0.000004 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    1              0.000007 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    1              0.000003 syn keyword cssAuralAttr contained leftwards rightwards behind
    1              0.000003 syn keyword cssAuralAttr contained below level above lower higher
    1              0.000005 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    1              0.000002 syn keyword cssAuralAttr contained faster slower
    1              0.000005 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    1              0.000004 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
    1              0.000003 syn keyword cssMediaProp contained width height orientation scan
    1              0.000003 syn keyword cssMediaProp contained any-hover any-pointer color-gamut grid hover
    1              0.000003 syn keyword cssMediaProp contained overflow-block overflow-inline pointer update
    1              0.000008 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio\>/
    1              0.000005 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=device-pixel-ratio\>/
    1              0.000006 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=device-\(height\|width\)\>/
    1              0.000011 syn match cssMediaProp contained /\<\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)\>/
    1              0.000003 syn keyword cssMediaAttr contained portrait landscape progressive interlace
    1              0.000004 syn keyword cssMediaAttr contained coarse fast fine hover infinite p3 paged
    1              0.000003 syn keyword cssMediaAttr contained rec2020 scroll slow srgb
    1              0.000009 syn match cssKeyFrameProp contained /\(\d\+\(\.\d\+\)\?%\|\(\<from\|to\>\)\)/ nextgroup=cssDefinition
    1              0.000012 syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
    1              0.000003 syn keyword cssPageProp contained content size
    1              0.000002 syn keyword cssPageProp contained orphans widows
    1              0.000002 syn keyword cssFontDescriptorProp contained src
    1              0.000005 syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
    1              0.000005 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    1              0.000004 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
    1              0.000003 syn match cssBraces contained "[{}]"
    1              0.000004 syn match cssError contained "{@<>"
    1              0.002257 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssCustomProp,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    1              0.000013 syn match cssBraceError "}"
    1              0.000004 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " https://www.w3.org/TR/selectors-4/
    1              0.000019 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    1              0.000007 syn keyword cssPseudoClassId contained link visited active hover before after left right
    1              0.000005 syn keyword cssPseudoClassId contained root empty target enabled disabled checked invalid
    1              0.000006 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    1              0.000009 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    1              0.000005 syn match cssPseudoClassId contained  "\<focus\(-within\|-visible\)\=\>"
    1              0.000071 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|is\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")" contains=cssStringQ,cssStringQQ,cssTagName,cssAttributeSelector,cssClassName,cssIdentifier
                            " ------------------------------------
                            " Vendor specific properties
    1              0.000004 syn match cssPseudoClassId contained  "\<selection\>"
    1              0.000005 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    1              0.000016 syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    1              0.000003 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    1              0.000009 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    1              0.000006 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    1              0.000003 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    1              0.000003 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    1              0.000009 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    1              0.000008 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    1              0.000005 syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    1              0.000003 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
                            " cssPseudoClassId is hidden by cssAttrRegion, so we add it here. see #69
    1              0.002965 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\|{\)/ contained contains=cssPseudoClassId,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    1              0.004206 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
    1              0.000017 syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/
                            
    1              0.000006 syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    1              0.000018 syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment,cssCustomProp,cssFunctionName nextgroup=cssDefinition
    1              0.000009 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    1              0.000009 syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
    1              0.000006 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    1              0.000011 syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
    1              0.000014 syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
    1              0.000008 syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
    1              0.000008 syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
    1              0.002099 syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
    1              0.000012 if main_syntax == "css"
                              syn sync minlines=10
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000003 hi def link cssComment Comment
    1              0.000001 hi def link cssVendor Comment
    1              0.000002 hi def link cssHacks Comment
    1              0.000002 hi def link cssTagName Statement
    1              0.000001 hi def link cssDeprecated Error
    1              0.000001 hi def link cssSelectorOp Special
    1              0.000001 hi def link cssSelectorOp2 Special
    1              0.000001 hi def link cssAttrComma Special
                            
    1              0.000002 hi def link cssAnimationProp cssProp
    1              0.000001 hi def link cssBackgroundProp cssProp
    1              0.000001 hi def link cssBorderProp cssProp
    1              0.000001 hi def link cssBoxProp cssProp
    1              0.000001 hi def link cssCascadeProp cssProp
    1              0.000001 hi def link cssColorProp cssProp
    1              0.000002 hi def link cssContentForPagedMediaProp cssProp
    1              0.000001 hi def link cssDimensionProp cssProp
    1              0.000001 hi def link cssFlexibleBoxProp cssProp
    1              0.000001 hi def link cssFontProp cssProp
    1              0.000002 hi def link cssGeneratedContentProp cssProp
    1              0.000001 hi def link cssGridProp cssProp
    1              0.000001 hi def link cssHyerlinkProp cssProp
    1              0.000001 hi def link cssInteractProp cssProp
    1              0.000001 hi def link cssLineboxProp cssProp
    1              0.000001 hi def link cssListProp cssProp
    1              0.000001 hi def link cssMarqueeProp cssProp
    1              0.000001 hi def link cssMultiColumnProp cssProp
    1              0.000001 hi def link cssPagedMediaProp cssProp
    1              0.000001 hi def link cssPositioningProp cssProp
    1              0.000001 hi def link cssObjectProp cssProp
    1              0.000001 hi def link cssPrintProp cssProp
    1              0.000001 hi def link cssRubyProp cssProp
    1              0.000001 hi def link cssSpeechProp cssProp
    1              0.000001 hi def link cssTableProp cssProp
    1              0.000001 hi def link cssTextProp cssProp
    1              0.000001 hi def link cssTransformProp cssProp
    1              0.000001 hi def link cssTransitionProp cssProp
    1              0.000001 hi def link cssUIProp cssProp
    1              0.000001 hi def link cssIEUIProp cssProp
    1              0.000001 hi def link cssAuralProp cssProp
    1              0.000001 hi def link cssRenderProp cssProp
    1              0.000001 hi def link cssMobileTextProp cssProp
                            
    1              0.000001 hi def link cssAnimationAttr cssAttr
    1              0.000001 hi def link cssBackgroundAttr cssAttr
    1              0.000001 hi def link cssBorderAttr cssAttr
    1              0.000001 hi def link cssBoxAttr cssAttr
    1              0.000001 hi def link cssContentForPagedMediaAttr cssAttr
    1              0.000001 hi def link cssDimensionAttr cssAttr
    1              0.000001 hi def link cssFlexibleBoxAttr cssAttr
    1              0.000001 hi def link cssFontAttr cssAttr
    1              0.000001 hi def link cssGeneratedContentAttr cssAttr
    1              0.000001 hi def link cssGridAttr cssAttr
    1              0.000001 hi def link cssHyerlinkAttr cssAttr
    1              0.000001 hi def link cssInteractAttr cssAttr
    1              0.000001 hi def link cssLineboxAttr cssAttr
    1              0.000001 hi def link cssListAttr cssAttr
    1              0.000001 hi def link cssMarginAttr cssAttr
    1              0.000001 hi def link cssMarqueeAttr cssAttr
    1              0.000001 hi def link cssMultiColumnAttr cssAttr
    1              0.000001 hi def link cssPaddingAttr cssAttr
    1              0.000002 hi def link cssPagedMediaAttr cssAttr
    1              0.000001 hi def link cssPositioningAttr cssAttr
    1              0.000001 hi def link cssObjectAttr cssAttr
    1              0.000001 hi def link cssGradientAttr cssAttr
    1              0.000001 hi def link cssPrintAttr cssAttr
    1              0.000001 hi def link cssRubyAttr cssAttr
    1              0.000001 hi def link cssSpeechAttr cssAttr
    1              0.000001 hi def link cssTableAttr cssAttr
    1              0.000001 hi def link cssTextAttr cssAttr
    1              0.000001 hi def link cssTransformAttr cssAttr
    1              0.000001 hi def link cssTransitionAttr cssAttr
    1              0.000001 hi def link cssUIAttr cssAttr
    1              0.000001 hi def link cssIEUIAttr cssAttr
    1              0.000001 hi def link cssAuralAttr cssAttr
    1              0.000001 hi def link cssRenderAttr cssAttr
    1              0.000001 hi def link cssCascadeAttr cssAttr
    1              0.000001 hi def link cssCommonAttr cssAttr
                            
    1              0.000001 hi def link cssPseudoClassId PreProc
    1              0.000002 hi def link cssPseudoClassLang Constant
    1              0.000001 hi def link cssValueLength Number
    1              0.000002 hi def link cssValueInteger Number
    1              0.000001 hi def link cssValueNumber Number
    1              0.000001 hi def link cssValueAngle Number
    1              0.000001 hi def link cssValueTime Number
    1              0.000001 hi def link cssValueFrequency Number
    1              0.000001 hi def link cssFunction Constant
    1              0.000001 hi def link cssURL String
    1              0.000001 hi def link cssFunctionName Function
    1              0.000001 hi def link cssFunctionComma Function
    1              0.000001 hi def link cssColor Constant
    1              0.000001 hi def link cssIdentifier Function
    1              0.000001 hi def link cssAtRule Include
    1              0.000001 hi def link cssAtKeyword PreProc
    1              0.000001 hi def link cssImportant Special
    1              0.000001 hi def link cssCustomProp Special
    1              0.000001 hi def link cssBraces Function
    1              0.000001 hi def link cssBraceError Error
    1              0.000001 hi def link cssError Error
    1              0.000006 hi def link cssUnicodeEscape Special
    1              0.000001 hi def link cssStringQQ String
    1              0.000001 hi def link cssStringQ String
    1              0.000001 hi def link cssAttributeSelector String
    1              0.000001 hi def link cssMediaType Special
    1              0.000001 hi def link cssMediaComma Normal
    1              0.000001 hi def link cssAtRuleLogical Statement
    1              0.000001 hi def link cssMediaProp cssProp
    1              0.000001 hi def link cssMediaAttr cssAttr
    1              0.000001 hi def link cssPagePseudo PreProc
    1              0.000001 hi def link cssPageMarginProp cssAtKeyword
    1              0.000001 hi def link cssPageProp cssProp
    1              0.000001 hi def link cssKeyFrameProp Constant
    1              0.000001 hi def link cssFontDescriptor Special
    1              0.000001 hi def link cssFontDescriptorProp cssProp
    1              0.000001 hi def link cssFontDescriptorAttr cssAttr
    1              0.000001 hi def link cssUnicodeRange Constant
    1              0.000001 hi def link cssClassName Function
    1              0.000001 hi def link cssClassNameDot Function
    1              0.000001 hi def link cssProp StorageClass
    1              0.000001 hi def link cssAttr Constant
    1              0.000001 hi def link cssUnitDecorators Number
    1              0.000001 hi def link cssNoise Noise
                            
    1              0.000006 let b:current_syntax = "css"
                            
    1              0.000002 if main_syntax == 'css'
                              unlet main_syntax
    1              0.000001 endif
                            
    1   0.000072   0.000026 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/yaml.vim
Sourced 1 time
Total time:   0.003426
 Self time:   0.003120

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:         YAML (YAML Ain't Markup Language) 1.2
                            " Maintainer:       Nikolai Pavlov <zyx.vim@gmail.com>
                            " First author:     Nikolai Weibull <now@bitwi.se>
                            " Latest Revision:  2015-03-28
                            " 		    removed duplicate yamlKeyValueDelimiter (pull #4799)
                            
    1              0.000018 if exists('b:current_syntax')
                                finish
    1              0.000002 endif
                            
    1              0.000018 let s:cpo_save = &cpo
    1   0.000086   0.000023 set cpo&vim
                            
                            " Choose the schema to use
                            " TODO: Validate schema
    1              0.000007 if !exists('b:yaml_schema')
    1              0.000004   if exists('g:yaml_schema')
                                let b:yaml_schema = g:yaml_schema
    1              0.000002   else
    1              0.000004     let b:yaml_schema = 'core'
    1              0.000001   endif
    1              0.000001 endif
                            
    1              0.000004 let s:ns_char = '\%([\n\r\uFEFF \t]\@!\p\)'
    1              0.000003 let s:ns_word_char = '[[:alnum:]_\-]'
    1              0.000007 let s:ns_uri_char  = '\%(%\x\x\|'.s:ns_word_char.'\|[#/;?:@&=+$,.!~*''()[\]]\)'
    1              0.000005 let s:ns_tag_char  = '\%(%\x\x\|'.s:ns_word_char.'\|[#/;?:@&=+$.~*''()]\)'
    1              0.000004 let s:c_ns_anchor_char = '\%([\n\r\uFEFF \t,[\]{}]\@!\p\)'
    1              0.000003 let s:c_indicator      = '[\-?:,[\]{}#&*!|>''"%@`]'
    1              0.000003 let s:c_flow_indicator = '[,[\]{}]'
                            
    1              0.000026 let s:ns_char_without_c_indicator = substitute(s:ns_char, '\v\C[\zs', '\=s:c_indicator[1:-2]', '')
                            
    1              0.000004 let s:_collection = '[^\@!\(\%(\\\.\|\[^\\\]]\)\+\)]'
    1              0.000004 let s:_neg_collection = '[^\(\%(\\\.\|\[^\\\]]\)\+\)]'
    1              0.000008 function s:SimplifyToAssumeAllPrintable(p)
                                return substitute(a:p, '\V\C\\%('.s:_collection.'\\@!\\p\\)', '[^\1]', '')
                            endfunction
    1   0.000071   0.000023 let s:ns_char = s:SimplifyToAssumeAllPrintable(s:ns_char)
    1   0.000050   0.000018 let s:ns_char_without_c_indicator = s:SimplifyToAssumeAllPrintable(s:ns_char_without_c_indicator)
    1   0.000038   0.000015 let s:c_ns_anchor_char = s:SimplifyToAssumeAllPrintable(s:c_ns_anchor_char)
                            
    1              0.000005 function s:SimplifyAdjacentCollections(p)
                                return substitute(a:p, '\V\C'.s:_collection.'\\|'.s:_collection, '[\1\2]', 'g')
                            endfunction
    1   0.000062   0.000015 let s:ns_uri_char = s:SimplifyAdjacentCollections(s:ns_uri_char)
    1   0.000041   0.000015 let s:ns_tag_char = s:SimplifyAdjacentCollections(s:ns_tag_char)
                            
    1              0.000005 let s:c_verbatim_tag = '!<'.s:ns_uri_char.'\+>'
    1              0.000005 let s:c_named_tag_handle     = '!'.s:ns_word_char.'\+!'
    1              0.000003 let s:c_secondary_tag_handle = '!!'
    1              0.000004 let s:c_primary_tag_handle   = '!'
    1              0.000011 let s:c_tag_handle = '\%('.s:c_named_tag_handle.
                                        \         '\|'.s:c_secondary_tag_handle.
                                        \         '\|'.s:c_primary_tag_handle.'\)'
    1              0.000005 let s:c_ns_shorthand_tag = s:c_tag_handle . s:ns_tag_char.'\+'
    1              0.000003 let s:c_non_specific_tag = '!'
    1              0.000009 let s:c_ns_tag_property = s:c_verbatim_tag.
                                        \        '\|'.s:c_ns_shorthand_tag.
                                        \        '\|'.s:c_non_specific_tag
                            
    1              0.000004 let s:c_ns_anchor_name = s:c_ns_anchor_char.'\+'
    1              0.000004 let s:c_ns_anchor_property =  '&'.s:c_ns_anchor_name
    1              0.000004 let s:c_ns_alias_node      = '\*'.s:c_ns_anchor_name
                            
    1              0.000003 let s:ns_directive_name = s:ns_char.'\+'
                            
    1              0.000004 let s:ns_local_tag_prefix  = '!'.s:ns_uri_char.'*'
    1              0.000006 let s:ns_global_tag_prefix = s:ns_tag_char.s:ns_uri_char.'*'
    1              0.000034 let s:ns_tag_prefix = s:ns_local_tag_prefix.
                                        \    '\|'.s:ns_global_tag_prefix
                            
    1              0.000004 let s:ns_plain_safe_out = s:ns_char
    1              0.000007 let s:ns_plain_safe_in  = '\%('.s:c_flow_indicator.'\@!'.s:ns_char.'\)'
                            
    1              0.000039 let s:ns_plain_safe_in = substitute(s:ns_plain_safe_in, '\V\C\\%('.s:_collection.'\\@!'.s:_neg_collection.'\\)', '[^\1\2]', '')
    1              0.000022 let s:ns_plain_safe_in_without_colhash = substitute(s:ns_plain_safe_in, '\V\C'.s:_neg_collection, '[^\1:#]', '')
    1              0.000018 let s:ns_plain_safe_out_without_colhash = substitute(s:ns_plain_safe_out, '\V\C'.s:_neg_collection, '[^\1:#]', '')
                            
    1              0.000017 let s:ns_plain_first_in  = '\%('.s:ns_char_without_c_indicator.'\|[?:\-]\%('.s:ns_plain_safe_in.'\)\@=\)'
    1              0.000005 let s:ns_plain_first_out = '\%('.s:ns_char_without_c_indicator.'\|[?:\-]\%('.s:ns_plain_safe_out.'\)\@=\)'
                            
    1              0.000006 let s:ns_plain_char_in  = '\%('.s:ns_char.'#\|:'.s:ns_plain_safe_in.'\|'.s:ns_plain_safe_in_without_colhash.'\)'
    1              0.000006 let s:ns_plain_char_out = '\%('.s:ns_char.'#\|:'.s:ns_plain_safe_out.'\|'.s:ns_plain_safe_out_without_colhash.'\)'
                            
    1              0.000004 let s:ns_plain_out = s:ns_plain_first_out . s:ns_plain_char_out.'*'
    1              0.000004 let s:ns_plain_in  = s:ns_plain_first_in  . s:ns_plain_char_in.'*'
                            
                            
    1              0.000010 syn keyword yamlTodo            contained TODO FIXME XXX NOTE
                            
    1              0.000013 syn region  yamlComment         display oneline start='\%\(^\|\s\)#' end='$'
                                        \                   contains=yamlTodo
                            
    1              0.000039 execute 'syn region yamlDirective oneline start='.string('^\ze%'.s:ns_directive_name.'\s\+').' '.
                                        \                            'end="$" '.
                                        \                            'contains=yamlTAGDirective,'.
                                        \                                     'yamlYAMLDirective,'.
                                        \                                     'yamlReservedDirective '.
                                        \                            'keepend'
                            
    1              0.000007 syn match yamlTAGDirective '%TAG\s\+' contained nextgroup=yamlTagHandle
    1              0.000016 execute 'syn match yamlTagHandle contained nextgroup=yamlTagPrefix '.string(s:c_tag_handle.'\s\+')
    1              0.000026 execute 'syn match yamlTagPrefix contained nextgroup=yamlComment ' . string(s:ns_tag_prefix)
                            
    1              0.000006 syn match yamlYAMLDirective '%YAML\s\+'  contained nextgroup=yamlYAMLVersion
    1              0.000005 syn match yamlYAMLVersion   '\d\+\.\d\+' contained nextgroup=yamlComment
                            
    1              0.000017 execute 'syn match yamlReservedDirective contained nextgroup=yamlComment '.
                                        \string('%\%(\%(TAG\|YAML\)\s\)\@!'.s:ns_directive_name)
                            
    1              0.000013 syn region yamlFlowString matchgroup=yamlFlowStringDelimiter start='"' skip='\\"' end='"'
                                        \ contains=yamlEscape
                                        \ nextgroup=yamlKeyValueDelimiter
    1              0.000011 syn region yamlFlowString matchgroup=yamlFlowStringDelimiter start="'" skip="''"  end="'"
                                        \ contains=yamlSingleEscape
                                        \ nextgroup=yamlKeyValueDelimiter
    1              0.000010 syn match  yamlEscape contained '\\\%([\\"abefnrtv\^0_ NLP\n]\|x\x\x\|u\x\{4}\|U\x\{8}\)'
    1              0.000003 syn match  yamlSingleEscape contained "''"
                            
    1              0.000008 syn match yamlBlockScalarHeader contained '\s\+\zs[|>]\%([+-]\=[1-9]\|[1-9]\=[+-]\)\='
                            
    1              0.000006 syn cluster yamlConstant contains=yamlBool,yamlNull
                            
    1              0.000005 syn cluster yamlFlow contains=yamlFlowString,yamlFlowMapping,yamlFlowCollection
    1              0.000004 syn cluster yamlFlow      add=yamlFlowMappingKey,yamlFlowMappingMerge
    1              0.000005 syn cluster yamlFlow      add=@yamlConstant,yamlPlainScalar,yamlFloat
    1              0.000005 syn cluster yamlFlow      add=yamlTimestamp,yamlInteger,yamlMappingKeyStart
    1              0.000003 syn cluster yamlFlow      add=yamlComment
    1              0.000008 syn region yamlFlowMapping    matchgroup=yamlFlowIndicator start='{' end='}' contains=@yamlFlow
    1              0.000007 syn region yamlFlowCollection matchgroup=yamlFlowIndicator start='\[' end='\]' contains=@yamlFlow
                            
    1              0.000018 execute 'syn match yamlPlainScalar /'.s:ns_plain_out.'/'
    1              0.000017 execute 'syn match yamlPlainScalar contained /'.s:ns_plain_in.'/'
                            
    1              0.000004 syn match yamlMappingKeyStart '?\ze\s'
    1              0.000003 syn match yamlMappingKeyStart '?' contained
                            
    1              0.000042 execute 'syn match yamlFlowMappingKey /\%#=1'.s:ns_plain_in.'\%(\s\+'.s:ns_plain_in.'\)*\ze\s*:/ contained '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    1              0.000005 syn match yamlFlowMappingMerge /<<\ze\s*:/ contained nextgroup=yamlKeyValueDelimiter
                            
    1              0.000008 syn match yamlBlockCollectionItemStart '^\s*\zs-\%(\s\+-\)*\s' nextgroup=yamlBlockMappingKey,yamlBlockMappingMerge
                            " Use the old regexp engine, the NFA engine doesn't like all the \@ items.
    1              0.000035 execute 'syn match yamlBlockMappingKey /\%#=1^\s*\zs'.s:ns_plain_out.'\%(\s\+'.s:ns_plain_out.'\)*\ze\s*:\%(\s\|$\)/ '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    1              0.000031 execute 'syn match yamlBlockMappingKey /\%#=1\s*\zs'.s:ns_plain_out.'\%(\s\+'.s:ns_plain_out.'\)*\ze\s*:\%(\s\|$\)/ contained '.
                                        \'nextgroup=yamlKeyValueDelimiter'
    1              0.000007 syn match yamlBlockMappingMerge /^\s*\zs<<\ze:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter
    1              0.000005 syn match yamlBlockMappingMerge /<<\ze\s*:\%(\s\|$\)/ nextgroup=yamlKeyValueDelimiter contained
                            
    1              0.000003 syn match   yamlKeyValueDelimiter /\s*:/ contained
                            
    1              0.000005 syn cluster yamlScalarWithSpecials contains=yamlPlainScalar,yamlBlockMappingKey,yamlFlowMappingKey
                            
    1   0.000042   0.000018 let s:_bounder = s:SimplifyToAssumeAllPrintable('\%([[\]{}, \t]\@!\p\)')
    1              0.000007 if b:yaml_schema is# 'json'
                                syn keyword yamlNull null contained containedin=@yamlScalarWithSpecials
                                syn keyword yamlBool true false
                                exe 'syn match   yamlInteger /'.s:_bounder.'\@1<!\%(0\|-\=[1-9][0-9]*\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match   yamlFloat   /'.s:_bounder.'\@1<!\%(-\=[1-9][0-9]*\%(\.[0-9]*\)\=\(e[-+]\=[0-9]\+\)\=\|0\|-\=\.inf\|\.nan\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
    1              0.000003 elseif b:yaml_schema is# 'core'
    1              0.000009     syn keyword yamlNull null Null NULL contained containedin=@yamlScalarWithSpecials
    1              0.000007     syn keyword yamlBool true True TRUE false False FALSE contained containedin=@yamlScalarWithSpecials
    1              0.000015     exe 'syn match   yamlNull /'.s:_bounder.'\@1<!\~'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
    1              0.000030     exe 'syn match   yamlInteger /'.s:_bounder.'\@1<!\%([+-]\=\%(0\%(b[0-1_]\+\|[0-7_]\+\|x[0-9a-fA-F_]\+\)\=\|\%([1-9][0-9_]*\%(:[0-5]\=\d\)\+\)\)\|[1-9][0-9_]*\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
    1              0.000033     exe 'syn match   yamlFloat /'.s:_bounder.'\@1<!\%([+-]\=\%(\%(\d[0-9_]*\)\.[0-9_]*\%([eE][+-]\=\d\+\)\=\|\.[0-9_]\+\%([eE][-+]\=[0-9]\+\)\=\|\d[0-9_]*\%(:[0-5]\=\d\)\+\.[0-9_]*\|\.\%(inf\|Inf\|INF\)\)\|\%(\.\%(nan\|NaN\|NAN\)\)\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                            elseif b:yaml_schema is# 'pyyaml'
                                syn keyword yamlNull null Null NULL contained containedin=@yamlScalarWithSpecials
                                syn keyword yamlBool true True TRUE false False FALSE yes Yes YES no No NO on On ON off Off OFF contained containedin=@yamlScalarWithSpecials
                                exe 'syn match   yamlNull /'.s:_bounder.'\@1<!\~'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match  yamlFloat /'.s:_bounder.'\@1<!\%(\v[-+]?%(\d[0-9_]*)\.[0-9_]*%([eE][-+]\d+)?|\.[0-9_]+%([eE][-+]\d+)?|[-+]?\d[0-9_]*%(\:[0-5]?\d)+\.[0-9_]*|[-+]?\.%(inf|Inf|INF)|\.%(nan|NaN|NAN)\m\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match  yamlInteger /'.s:_bounder.'\@1<!\%(\v[-+]?0b[0-1_]+|[-+]?0[0-7_]+|[-+]?%(0|[1-9][0-9_]*)|[-+]?0x[0-9a-fA-F_]+|[-+]?[1-9][0-9_]*%(:[0-5]?\d)+\m\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                                exe 'syn match  yamlTimestamp /'.s:_bounder.'\@1<!\%(\v\d\d\d\d\-\d\d\-\d\d|\d\d\d\d \-\d\d? \-\d\d?%([Tt]|[ \t]+)\d\d?\:\d\d \:\d\d %(\.\d*)?%([ \t]*%(Z|[-+]\d\d?%(\:\d\d)?))?\m\)'.s:_bounder.'\@!/ contained containedin=@yamlScalarWithSpecials'
                            elseif b:yaml_schema is# 'failsafe'
                                " Nothing
    1              0.000001 endif
    1              0.000003 unlet s:_bounder
                            
                            
    1              0.000027 execute 'syn match yamlNodeTag '.string(s:c_ns_tag_property)
    1              0.000012 execute 'syn match yamlAnchor  '.string(s:c_ns_anchor_property)
    1              0.000010 execute 'syn match yamlAlias   '.string(s:c_ns_alias_node)
                            
    1              0.000006 syn match yamlDocumentStart '^---\ze\%(\s\|$\)'
    1              0.000005 syn match yamlDocumentEnd   '^\.\.\.\ze\%(\s\|$\)'
                            
    1              0.000004 hi def link yamlTodo                     Todo
    1              0.000002 hi def link yamlComment                  Comment
                            
    1              0.000002 hi def link yamlDocumentStart            PreProc
    1              0.000002 hi def link yamlDocumentEnd              PreProc
                            
    1              0.000002 hi def link yamlDirectiveName            Keyword
                            
    1              0.000002 hi def link yamlTAGDirective             yamlDirectiveName
    1              0.000002 hi def link yamlTagHandle                String
    1              0.000002 hi def link yamlTagPrefix                String
                            
    1              0.000002 hi def link yamlYAMLDirective            yamlDirectiveName
    1              0.000002 hi def link yamlReservedDirective        Error
    1              0.000002 hi def link yamlYAMLVersion              Number
                            
    1              0.000002 hi def link yamlString                   String
    1              0.000002 hi def link yamlFlowString               yamlString
    1              0.000002 hi def link yamlFlowStringDelimiter      yamlString
    1              0.000002 hi def link yamlEscape                   SpecialChar
    1              0.000002 hi def link yamlSingleEscape             SpecialChar
                            
    1              0.000002 hi def link yamlBlockCollectionItemStart Label
    1              0.000002 hi def link yamlBlockMappingKey          Identifier
    1              0.000002 hi def link yamlBlockMappingMerge        Special
                            
    1              0.000002 hi def link yamlFlowMappingKey           Identifier
    1              0.000002 hi def link yamlFlowMappingMerge         Special
                            
    1              0.000002 hi def link yamlMappingKeyStart          Special
    1              0.000002 hi def link yamlFlowIndicator            Special
    1              0.000002 hi def link yamlKeyValueDelimiter        Special
                            
    1              0.000002 hi def link yamlConstant                 Constant
                            
    1              0.000002 hi def link yamlNull                     yamlConstant
    1              0.000002 hi def link yamlBool                     yamlConstant
                            
    1              0.000002 hi def link yamlAnchor                   Type
    1              0.000002 hi def link yamlAlias                    Type
    1              0.000002 hi def link yamlNodeTag                  Type
                            
    1              0.000002 hi def link yamlInteger                  Number
    1              0.000002 hi def link yamlFloat                    Float
    1              0.000002 hi def link yamlTimestamp                Number
                            
    1              0.000004 let b:current_syntax = "yaml"
                            
    1              0.000023 unlet s:ns_word_char s:ns_uri_char s:c_verbatim_tag s:c_named_tag_handle s:c_secondary_tag_handle s:c_primary_tag_handle s:c_tag_handle s:ns_tag_char s:c_ns_shorthand_tag s:c_non_specific_tag s:c_ns_tag_property s:c_ns_anchor_char s:c_ns_anchor_name s:c_ns_anchor_property s:c_ns_alias_node s:ns_char s:ns_directive_name s:ns_local_tag_prefix s:ns_global_tag_prefix s:ns_tag_prefix s:c_indicator s:ns_plain_safe_out s:c_flow_indicator s:ns_plain_safe_in s:ns_plain_first_in s:ns_plain_first_out s:ns_plain_char_in s:ns_plain_char_out s:ns_plain_out s:ns_plain_in s:ns_char_without_c_indicator s:ns_plain_safe_in_without_colhash s:ns_plain_safe_out_without_colhash
    1              0.000002 unlet s:_collection s:_neg_collection
    1              0.000005 delfunction s:SimplifyAdjacentCollections
    1              0.000003 delfunction s:SimplifyToAssumeAllPrintable
                            
    1   0.000069   0.000024 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim
Sourced 1 time
Total time:   0.001119
 Self time:   0.000996

count  total (s)   self (s)
                            "  matchit.vim: (global plugin) Extended "%" matching
                            "  autload script of matchit plugin, see ../plugin/matchit.vim
                            "  Last Change: Jun 10, 2021
                            
                            " Neovim does not support scriptversion
    1              0.000020 if has("vimscript-4")
                              scriptversion 4
    1              0.000002 endif
                            
    1              0.000007 let s:last_mps = ""
    1              0.000003 let s:last_words = ":"
    1              0.000002 let s:patBR = ""
                            
    1              0.000012 let s:save_cpo = &cpo
    1   0.000098   0.000023 set cpo&vim
                            
                            " Auto-complete mappings:  (not yet "ready for prime time")
                            " TODO Read :help write-plugin for the "right" way to let the user
                            " specify a key binding.
                            "   let g:match_auto = '<C-]>'
                            "   let g:match_autoCR = '<C-CR>'
                            " if exists("g:match_auto")
                            "   execute "inoremap " . g:match_auto . ' x<Esc>"=<SID>Autocomplete()<CR>Pls'
                            " endif
                            " if exists("g:match_autoCR")
                            "   execute "inoremap " . g:match_autoCR . ' <CR><C-R>=<SID>Autocomplete()<CR>'
                            " endif
                            " if exists("g:match_gthhoh")
                            "   execute "inoremap " . g:match_gthhoh . ' <C-O>:call <SID>Gthhoh()<CR>'
                            " endif " gthhoh = "Get the heck out of here!"
                            
    1              0.000006 let s:notslash = '\\\@1<!\%(\\\\\)*'
                            
    1              0.000006 function s:RestoreOptions()
                              " In s:CleanUp(), :execute "set" restore_options .
                              let restore_options = ""
                              if get(b:, 'match_ignorecase', &ic) != &ic
                                let restore_options ..= (&ic ? " " : " no") .. "ignorecase"
                                let &ignorecase = b:match_ignorecase
                              endif
                              if &ve != ''
                                let restore_options = " ve=" .. &ve .. restore_options
                                set ve=
                              endif
                              return restore_options
                            endfunction
                            
    1              0.000005 function matchit#Match_wrapper(word, forward, mode) range
                              let restore_options = s:RestoreOptions()
                              " In s:CleanUp(), we may need to check whether the cursor moved forward.
                              let startpos = [line("."), col(".")]
                              " if a count has been applied, use the default [count]% mode (see :h N%)
                              if v:count
                                exe "normal! " .. v:count .. "%"
                                return s:CleanUp(restore_options, a:mode, startpos)
                              end
                              if a:mode =~# "v" && mode(1) =~# 'ni'
                                exe "norm! gv"
                              elseif a:mode == "o" && mode(1) !~# '[vV]'
                                exe "norm! v"
                              " If this function was called from Visual mode, make sure that the cursor
                              " is at the correct end of the Visual range:
                              elseif a:mode == "v"
                                execute "normal! gv\<Esc>"
                                let startpos = [line("."), col(".")]
                              endif
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR   flag for whether there are backrefs
                              "   s:pat     parsed version of b:match_words
                              "   s:all     regexp based on s:pat and the default groups
                              if !exists("b:match_words") || b:match_words == ""
                                let match_words = ""
                              elseif b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                " Allow b:match_words = "GetVimMatchWords()" .
                                execute "let match_words =" b:match_words
                              endif
                            " Thanks to Preben "Peppe" Guldberg and Bram Moolenaar for this suggestion!
                              if (match_words != s:last_words) || (&mps != s:last_mps)
                                  \ || exists("b:match_debug")
                                let s:last_mps = &mps
                                " quote the special chars in 'matchpairs', replace [,:] with \| and then
                                " append the builtin pairs (/*, */, #if, #ifdef, #ifndef, #else, #elif,
                                " #endif)
                                let default = escape(&mps, '[$^.*~\\/?]') .. (strlen(&mps) ? "," : "") ..
                                  \ '\/\*:\*\/,#\s*if\%(n\=def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                                " s:all = pattern with all the keywords
                                let match_words = match_words .. (strlen(match_words) ? "," : "") .. default
                                let s:last_words = match_words
                                if match_words !~ s:notslash .. '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = substitute(s:pat, s:notslash .. '\zs[,:]\+', '\\|', 'g')
                                " Just in case there are too many '\(...)' groups inside the pattern, make
                                " sure to use \%(...) groups, so that error E872 can be avoided
                                let s:all = substitute(s:all, '\\(', '\\%(', 'g')
                                let s:all = '\%(' .. s:all .. '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                                " Reconstruct the version with unresolved backrefs.
                                let s:patBR = substitute(match_words .. ',',
                                  \ s:notslash .. '\zs[,:]*,[,:]*', ',', 'g')
                                let s:patBR = substitute(s:patBR, s:notslash .. '\zs:\{2,}', ':', 'g')
                              endif
                            
                              " Second step:  set the following local variables:
                              "     matchline = line on which the cursor started
                              "     curcol    = number of characters before match
                              "     prefix    = regexp for start of line to start of match
                              "     suffix    = regexp for end of match to end of line
                              " Require match to end on or after the cursor and prefer it to
                              " start on or before the cursor.
                              let matchline = getline(startpos[0])
                              if a:word != ''
                                " word given
                                if a:word !~ s:all
                                  echohl WarningMsg|echo 'Missing rule for word:"'.a:word.'"'|echohl NONE
                                  return s:CleanUp(restore_options, a:mode, startpos)
                                endif
                                let matchline = a:word
                                let curcol = 0
                                let prefix = '^\%('
                                let suffix = '\)$'
                              " Now the case when "word" is not given
                              else  " Find the match that ends on or after the cursor and set curcol.
                                let regexp = s:Wholematch(matchline, s:all, startpos[1]-1)
                                let curcol = match(matchline, regexp)
                                " If there is no match, give up.
                                if curcol == -1
                                  " Make sure macros abort properly
                                  "exe "norm! \<esc>"
                                  call feedkeys("\e", 'tni')
                                  return s:CleanUp(restore_options, a:mode, startpos)
                                endif
                                let endcol = matchend(matchline, regexp)
                                let suf = strlen(matchline) - endcol
                                let prefix = (curcol ? '^.*\%' .. (curcol + 1) .. 'c\%(' : '^\%(')
                                let suffix = (suf ? '\)\%' .. (endcol + 1) .. 'c.*$'  : '\)$')
                              endif
                              if exists("b:match_debug")
                                let b:match_match = matchstr(matchline, regexp)
                                let b:match_col = curcol+1
                              endif
                            
                              " Third step:  Find the group and single word that match, and the original
                              " (backref) versions of these.  Then, resolve the backrefs.
                              " Set the following local variable:
                              " group = colon-separated list of patterns, one of which matches
                              "       = ini:mid:fin or ini:fin
                              "
                              " Now, set group and groupBR to the matching group: 'if:endif' or
                              " 'while:endwhile' or whatever.  A bit of a kluge:  s:Choose() returns
                              " group . "," . groupBR, and we pick it apart.
                              let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, s:patBR)
                              let i = matchend(group, s:notslash .. ",")
                              let groupBR = strpart(group, i)
                              let group = strpart(group, 0, i-1)
                              " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
                              if s:do_BR " Do the hard part:  resolve those backrefs!
                                let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              endif
                              if exists("b:match_debug")
                                let b:match_wholeBR = groupBR
                                let i = matchend(groupBR, s:notslash .. ":")
                                let b:match_iniBR = strpart(groupBR, 0, i-1)
                              endif
                            
                              " Fourth step:  Set the arguments for searchpair().
                              let i = matchend(group, s:notslash .. ":")
                              let j = matchend(group, '.*' .. s:notslash .. ":")
                              let ini = strpart(group, 0, i-1)
                              let mid = substitute(strpart(group, i,j-i-1), s:notslash .. '\zs:', '\\|', 'g')
                              let fin = strpart(group, j)
                              "Un-escape the remaining , and : characters.
                              let ini = substitute(ini, s:notslash .. '\zs\\\(:\|,\)', '\1', 'g')
                              let mid = substitute(mid, s:notslash .. '\zs\\\(:\|,\)', '\1', 'g')
                              let fin = substitute(fin, s:notslash .. '\zs\\\(:\|,\)', '\1', 'g')
                              " searchpair() requires that these patterns avoid \(\) groups.
                              let ini = substitute(ini, s:notslash .. '\zs\\(', '\\%(', 'g')
                              let mid = substitute(mid, s:notslash .. '\zs\\(', '\\%(', 'g')
                              let fin = substitute(fin, s:notslash .. '\zs\\(', '\\%(', 'g')
                              " Set mid.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix .. fin .. suffix
                                \ || !a:forward && matchline =~ prefix .. ini .. suffix
                                let mid = ""
                              endif
                              " Set flag.  This is optimized for readability, not micro-efficiency!
                              if a:forward && matchline =~ prefix .. fin .. suffix
                                \ || !a:forward && matchline !~ prefix .. ini .. suffix
                                let flag = "bW"
                              else
                                let flag = "W"
                              endif
                              " Set skip.
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" .. b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              if exists("b:match_debug")
                                let b:match_ini = ini
                                let b:match_tail = (strlen(mid) ? mid .. '\|' : '') .. fin
                              endif
                            
                              " Fifth step:  actually start moving the cursor and call searchpair().
                              " Later, :execute restore_cursor to get to the original screen.
                              let view = winsaveview()
                              call cursor(0, curcol + 1)
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = "0"
                              else
                                execute "if " .. skip .. "| let skip = '0' | endif"
                              endif
                              let sp_return = searchpair(ini, mid, fin, flag, skip)
                              if &selection isnot# 'inclusive' && a:mode == 'v'
                                " move cursor one pos to the right, because selection is not inclusive
                                " add virtualedit=onemore, to make it work even when the match ends the
                                " line
                                if !(col('.') < col('$')-1)
                                  let eolmark=1 " flag to set a mark on eol (since we cannot move there)
                                endif
                                norm! l
                              endif
                              let final_position = "call cursor(" .. line(".") .. "," .. col(".") .. ")"
                              " Restore cursor position and original screen.
                              call winrestview(view)
                              normal! m'
                              if sp_return > 0
                                execute final_position
                              endif
                              if exists('eolmark') && eolmark
                                call setpos("''", [0, line('.'), col('$'), 0]) " set mark on the eol
                              endif
                              return s:CleanUp(restore_options, a:mode, startpos, mid .. '\|' .. fin)
                            endfun
                            
                            " Restore options and do some special handling for Operator-pending mode.
                            " The optional argument is the tail of the matching group.
    1              0.000006 fun! s:CleanUp(options, mode, startpos, ...)
                              if strlen(a:options)
                                execute "set" a:options
                              endif
                              " Open folds, if appropriate.
                              if a:mode != "o"
                                if &foldopen =~ "percent"
                                  normal! zv
                                endif
                                " In Operator-pending mode, we want to include the whole match
                                " (for example, d%).
                                " This is only a problem if we end up moving in the forward direction.
                              elseif (a:startpos[0] < line(".")) ||
                                    \ (a:startpos[0] == line(".") && a:startpos[1] < col("."))
                                if a:0
                                  " Check whether the match is a single character.  If not, move to the
                                  " end of the match.
                                  let matchline = getline(".")
                                  let currcol = col(".")
                                  let regexp = s:Wholematch(matchline, a:1, currcol-1)
                                  let endcol = matchend(matchline, regexp)
                                  if endcol > currcol  " This is NOT off by one!
                                    call cursor(0, endcol)
                                  endif
                                endif " a:0
                              endif " a:mode != "o" && etc.
                              return 0
                            endfun
                            
                            " Example (simplified HTML patterns):  if
                            "   a:groupBR   = '<\(\k\+\)>:</\1>'
                            "   a:prefix    = '^.\{3}\('
                            "   a:group     = '<\(\k\+\)>:</\(\k\+\)>'
                            "   a:suffix    = '\).\{2}$'
                            "   a:matchline =  "123<tag>12" or "123</tag>12"
                            " then extract "tag" from a:matchline and return "<tag>:</tag>" .
    1              0.000005 fun! s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                              if a:matchline !~ a:prefix ..
                                \ substitute(a:group, s:notslash .. '\zs:', '\\|', 'g') .. a:suffix
                                return a:group
                              endif
                              let i = matchend(a:groupBR, s:notslash .. ':')
                              let ini = strpart(a:groupBR, 0, i-1)
                              let tailBR = strpart(a:groupBR, i)
                              let word = s:Choose(a:group, a:matchline, ":", "", a:prefix, a:suffix,
                                \ a:groupBR)
                              let i = matchend(word, s:notslash .. ":")
                              let wordBR = strpart(word, i)
                              let word = strpart(word, 0, i-1)
                              " Now, a:matchline =~ a:prefix . word . a:suffix
                              if wordBR != ini
                                let table = s:Resolve(ini, wordBR, "table")
                              else
                                let table = ""
                                let d = 0
                                while d < 10
                                  if tailBR =~ s:notslash .. '\\' .. d
                                    let table = table .. d
                                  else
                                    let table = table .. "-"
                                  endif
                                  let d = d + 1
                                endwhile
                              endif
                              let d = 9
                              while d
                                if table[d] != "-"
                                  let backref = substitute(a:matchline, a:prefix .. word .. a:suffix,
                                    \ '\' .. table[d], "")
                                    " Are there any other characters that should be escaped?
                                  let backref = escape(backref, '*,:')
                                  execute s:Ref(ini, d, "start", "len")
                                  let ini = strpart(ini, 0, start) .. backref .. strpart(ini, start+len)
                                  let tailBR = substitute(tailBR, s:notslash .. '\zs\\' .. d,
                                    \ escape(backref, '\\&'), 'g')
                                endif
                                let d = d-1
                              endwhile
                              if exists("b:match_debug")
                                if s:do_BR
                                  let b:match_table = table
                                  let b:match_word = word
                                else
                                  let b:match_table = ""
                                  let b:match_word = ""
                                endif
                              endif
                              return ini .. ":" .. tailBR
                            endfun
                            
                            " Input a comma-separated list of groups with backrefs, such as
                            "   a:groups = '\(foo\):end\1,\(bar\):end\1'
                            " and return a comma-separated list of groups with backrefs replaced:
                            "   return '\(foo\):end\(foo\),\(bar\):end\(bar\)'
    1              0.000003 fun! s:ParseWords(groups)
                              let groups = substitute(a:groups .. ",", s:notslash .. '\zs[,:]*,[,:]*', ',', 'g')
                              let groups = substitute(groups, s:notslash .. '\zs:\{2,}', ':', 'g')
                              let parsed = ""
                              while groups =~ '[^,:]'
                                let i = matchend(groups, s:notslash .. ':')
                                let j = matchend(groups, s:notslash .. ',')
                                let ini = strpart(groups, 0, i-1)
                                let tail = strpart(groups, i, j-i-1) .. ":"
                                let groups = strpart(groups, j)
                                let parsed = parsed .. ini
                                let i = matchend(tail, s:notslash .. ':')
                                while i != -1
                                  " In 'if:else:endif', ini='if' and word='else' and then word='endif'.
                                  let word = strpart(tail, 0, i-1)
                                  let tail = strpart(tail, i)
                                  let i = matchend(tail, s:notslash .. ':')
                                  let parsed = parsed .. ":" .. s:Resolve(ini, word, "word")
                                endwhile " Now, tail has been used up.
                                let parsed = parsed .. ","
                              endwhile " groups =~ '[^,:]'
                              let parsed = substitute(parsed, ',$', '', '')
                              return parsed
                            endfun
                            
                            " TODO I think this can be simplified and/or made more efficient.
                            " TODO What should I do if a:start is out of range?
                            " Return a regexp that matches all of a:string, such that
                            " matchstr(a:string, regexp) represents the match for a:pat that starts
                            " as close to a:start as possible, before being preferred to after, and
                            " ends after a:start .
                            " Usage:
                            " let regexp = s:Wholematch(getline("."), 'foo\|bar', col(".")-1)
                            " let i      = match(getline("."), regexp)
                            " let j      = matchend(getline("."), regexp)
                            " let match  = matchstr(getline("."), regexp)
    1              0.000003 fun! s:Wholematch(string, pat, start)
                              let group = '\%(' .. a:pat .. '\)'
                              let prefix = (a:start ? '\(^.*\%<' .. (a:start + 2) .. 'c\)\zs' : '^')
                              let len = strlen(a:string)
                              let suffix = (a:start+1 < len ? '\(\%>' .. (a:start+1) .. 'c.*$\)\@=' : '$')
                              if a:string !~ prefix .. group .. suffix
                                let prefix = ''
                              endif
                              return prefix .. group .. suffix
                            endfun
                            
                            " No extra arguments:  s:Ref(string, d) will
                            " find the d'th occurrence of '\(' and return it, along with everything up
                            " to and including the matching '\)'.
                            " One argument:  s:Ref(string, d, "start") returns the index of the start
                            " of the d'th '\(' and any other argument returns the length of the group.
                            " Two arguments:  s:Ref(string, d, "foo", "bar") returns a string to be
                            " executed, having the effect of
                            "   :let foo = s:Ref(string, d, "start")
                            "   :let bar = s:Ref(string, d, "len")
    1              0.000002 fun! s:Ref(string, d, ...)
                              let len = strlen(a:string)
                              if a:d == 0
                                let start = 0
                              else
                                let cnt = a:d
                                let match = a:string
                                while cnt
                                  let cnt = cnt - 1
                                  let index = matchend(match, s:notslash .. '\\(')
                                  if index == -1
                                    return ""
                                  endif
                                  let match = strpart(match, index)
                                endwhile
                                let start = len - strlen(match)
                                if a:0 == 1 && a:1 == "start"
                                  return start - 2
                                endif
                                let cnt = 1
                                while cnt
                                  let index = matchend(match, s:notslash .. '\\(\|\\)') - 1
                                  if index == -2
                                    return ""
                                  endif
                                  " Increment if an open, decrement if a ')':
                                  let cnt = cnt + (match[index]=="(" ? 1 : -1)  " ')'
                                  let match = strpart(match, index+1)
                                endwhile
                                let start = start - 2
                                let len = len - start - strlen(match)
                              endif
                              if a:0 == 1
                                return len
                              elseif a:0 == 2
                                return "let " .. a:1 .. "=" .. start .. "| let " .. a:2 .. "=" .. len
                              else
                                return strpart(a:string, start, len)
                              endif
                            endfun
                            
                            " Count the number of disjoint copies of pattern in string.
                            " If the pattern is a literal string and contains no '0' or '1' characters
                            " then s:Count(string, pattern, '0', '1') should be faster than
                            " s:Count(string, pattern).
    1              0.000003 fun! s:Count(string, pattern, ...)
                              let pat = escape(a:pattern, '\\')
                              if a:0 > 1
                                let foo = substitute(a:string, '[^' .. a:pattern .. ']', "a:1", "g")
                                let foo = substitute(a:string, pat, a:2, "g")
                                let foo = substitute(foo, '[^' .. a:2 .. ']', "", "g")
                                return strlen(foo)
                              endif
                              let result = 0
                              let foo = a:string
                              let index = matchend(foo, pat)
                              while index != -1
                                let result = result + 1
                                let foo = strpart(foo, index)
                                let index = matchend(foo, pat)
                              endwhile
                              return result
                            endfun
                            
                            " s:Resolve('\(a\)\(b\)', '\(c\)\2\1\1\2') should return table.word, where
                            " word = '\(c\)\(b\)\(a\)\3\2' and table = '-32-------'.  That is, the first
                            " '\1' in target is replaced by '\(a\)' in word, table[1] = 3, and this
                            " indicates that all other instances of '\1' in target are to be replaced
                            " by '\3'.  The hard part is dealing with nesting...
                            " Note that ":" is an illegal character for source and target,
                            " unless it is preceded by "\".
    1              0.000003 fun! s:Resolve(source, target, output)
                              let word = a:target
                              let i = matchend(word, s:notslash .. '\\\d') - 1
                              let table = "----------"
                              while i != -2 " There are back references to be replaced.
                                let d = word[i]
                                let backref = s:Ref(a:source, d)
                                " The idea is to replace '\d' with backref.  Before we do this,
                                " replace any \(\) groups in backref with :1, :2, ... if they
                                " correspond to the first, second, ... group already inserted
                                " into backref.  Later, replace :1 with \1 and so on.  The group
                                " number w+b within backref corresponds to the group number
                                " s within a:source.
                                " w = number of '\(' in word before the current one
                                let w = s:Count(
                                \ substitute(strpart(word, 0, i-1), '\\\\', '', 'g'), '\(', '1')
                                let b = 1 " number of the current '\(' in backref
                                let s = d " number of the current '\(' in a:source
                                while b <= s:Count(substitute(backref, '\\\\', '', 'g'), '\(', '1')
                                \ && s < 10
                                  if table[s] == "-"
                                    if w + b < 10
                                      " let table[s] = w + b
                                      let table = strpart(table, 0, s) .. (w+b) .. strpart(table, s+1)
                                    endif
                                    let b = b + 1
                                    let s = s + 1
                                  else
                                    execute s:Ref(backref, b, "start", "len")
                                    let ref = strpart(backref, start, len)
                                    let backref = strpart(backref, 0, start) .. ":" .. table[s]
                                    \ .. strpart(backref, start+len)
                                    let s = s + s:Count(substitute(ref, '\\\\', '', 'g'), '\(', '1')
                                  endif
                                endwhile
                                let word = strpart(word, 0, i-1) .. backref .. strpart(word, i+1)
                                let i = matchend(word, s:notslash .. '\\\d') - 1
                              endwhile
                              let word = substitute(word, s:notslash .. '\zs:', '\\', 'g')
                              if a:output == "table"
                                return table
                              elseif a:output == "word"
                                return word
                              else
                                return table .. word
                              endif
                            endfun
                            
                            " Assume a:comma = ",".  Then the format for a:patterns and a:1 is
                            "   a:patterns = "<pat1>,<pat2>,..."
                            "   a:1 = "<alt1>,<alt2>,..."
                            " If <patn> is the first pattern that matches a:string then return <patn>
                            " if no optional arguments are given; return <patn>,<altn> if a:1 is given.
    1              0.000004 fun! s:Choose(patterns, string, comma, branch, prefix, suffix, ...)
                              let tail = (a:patterns =~ a:comma .. "$" ? a:patterns : a:patterns .. a:comma)
                              let i = matchend(tail, s:notslash .. a:comma)
                              if a:0
                                let alttail = (a:1 =~ a:comma .. "$" ? a:1 : a:1 .. a:comma)
                                let j = matchend(alttail, s:notslash .. a:comma)
                              endif
                              let current = strpart(tail, 0, i-1)
                              if a:branch == ""
                                let currpat = current
                              else
                                let currpat = substitute(current, s:notslash .. a:branch, '\\|', 'g')
                              endif
                              while a:string !~ a:prefix .. currpat .. a:suffix
                                let tail = strpart(tail, i)
                                let i = matchend(tail, s:notslash .. a:comma)
                                if i == -1
                                  return -1
                                endif
                                let current = strpart(tail, 0, i-1)
                                if a:branch == ""
                                  let currpat = current
                                else
                                  let currpat = substitute(current, s:notslash .. a:branch, '\\|', 'g')
                                endif
                                if a:0
                                  let alttail = strpart(alttail, j)
                                  let j = matchend(alttail, s:notslash .. a:comma)
                                endif
                              endwhile
                              if a:0
                                let current = current .. a:comma .. strpart(alttail, 0, j-1)
                              endif
                              return current
                            endfun
                            
    1              0.000003 fun! matchit#Match_debug()
                              let b:match_debug = 1 " Save debugging information.
                              " pat = all of b:match_words with backrefs parsed
                              amenu &Matchit.&pat   :echo b:match_pat<CR>
                              " match = bit of text that is recognized as a match
                              amenu &Matchit.&match :echo b:match_match<CR>
                              " curcol = cursor column of the start of the matching text
                              amenu &Matchit.&curcol        :echo b:match_col<CR>
                              " wholeBR = matching group, original version
                              amenu &Matchit.wh&oleBR       :echo b:match_wholeBR<CR>
                              " iniBR = 'if' piece, original version
                              amenu &Matchit.ini&BR :echo b:match_iniBR<CR>
                              " ini = 'if' piece, with all backrefs resolved from match
                              amenu &Matchit.&ini   :echo b:match_ini<CR>
                              " tail = 'else\|endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&tail  :echo b:match_tail<CR>
                              " fin = 'endif' piece, with all backrefs resolved from match
                              amenu &Matchit.&word  :echo b:match_word<CR>
                              " '\'.d in ini refers to the same thing as '\'.table[d] in word.
                              amenu &Matchit.t&able :echo '0:' .. b:match_table .. ':9'<CR>
                            endfun
                            
                            " Jump to the nearest unmatched "(" or "if" or "<tag>" if a:spflag == "bW"
                            " or the nearest unmatched "</tag>" or "endif" or ")" if a:spflag == "W".
                            " Return a "mark" for the original position, so that
                            "   let m = MultiMatch("bW", "n") ... call winrestview(m)
                            " will return to the original position.  If there is a problem, do not
                            " move the cursor and return {}, unless a count is given, in which case
                            " go up or down as many levels as possible and again return {}.
                            " TODO This relies on the same patterns as % matching.  It might be a good
                            " idea to give it its own matching patterns.
    1              0.000003 fun! matchit#MultiMatch(spflag, mode)
                              let restore_options = s:RestoreOptions()
                              let startpos = [line("."), col(".")]
                              " save v:count1 variable, might be reset from the restore_cursor command
                              let level = v:count1
                              if a:mode == "o" && mode(1) !~# '[vV]'
                                exe "norm! v"
                              endif
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR   flag for whether there are backrefs
                              "   s:pat     parsed version of b:match_words
                              "   s:all     regexp based on s:pat and the default groups
                              " This part is copied and slightly modified from matchit#Match_wrapper().
                              if !exists("b:match_words") || b:match_words == ""
                                let match_words = ""
                                " Allow b:match_words = "GetVimMatchWords()" .
                              elseif b:match_words =~ ":"
                                let match_words = b:match_words
                              else
                                execute "let match_words =" b:match_words
                              endif
                              if (match_words != s:last_words) || (&mps != s:last_mps) ||
                                \ exists("b:match_debug")
                                let default = escape(&mps, '[$^.*~\\/?]') .. (strlen(&mps) ? "," : "") ..
                                  \ '\/\*:\*\/,#\s*if\%(n\=def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                                let s:last_mps = &mps
                                let match_words = match_words .. (strlen(match_words) ? "," : "") .. default
                                let s:last_words = match_words
                                if match_words !~ s:notslash .. '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
                                else
                                  let s:do_BR = 1
                                  let s:pat = s:ParseWords(match_words)
                                endif
                                let s:all = '\%(' .. substitute(s:pat, '[,:]\+', '\\|', 'g') .. '\)'
                                if exists("b:match_debug")
                                  let b:match_pat = s:pat
                                endif
                                " Reconstruct the version with unresolved backrefs.
                                let s:patBR = substitute(match_words .. ',',
                                  \ s:notslash .. '\zs[,:]*,[,:]*', ',', 'g')
                                let s:patBR = substitute(s:patBR, s:notslash .. '\zs:\{2,}', ':', 'g')
                              endif
                            
                              " Second step:  figure out the patterns for searchpair()
                              " and save the screen, cursor position, and 'ignorecase'.
                              " - TODO:  A lot of this is copied from matchit#Match_wrapper().
                              " - maybe even more functionality should be split off
                              " - into separate functions!
                              let openlist = split(s:pat .. ',', s:notslash .. '\zs:.\{-}' .. s:notslash .. ',')
                              let midclolist = split(',' .. s:pat, s:notslash .. '\zs,.\{-}' .. s:notslash .. ':')
                              call map(midclolist, {-> split(v:val, s:notslash .. ':')})
                              let closelist = []
                              let middlelist = []
                              call map(midclolist, {i,v -> [extend(closelist, v[-1 : -1]),
                                    \ extend(middlelist, v[0 : -2])]})
                              call map(openlist,   {i,v -> v =~# s:notslash .. '\\|' ? '\%(' .. v .. '\)' : v})
                              call map(middlelist, {i,v -> v =~# s:notslash .. '\\|' ? '\%(' .. v .. '\)' : v})
                              call map(closelist,  {i,v -> v =~# s:notslash .. '\\|' ? '\%(' .. v .. '\)' : v})
                              let open   = join(openlist, ',')
                              let middle = join(middlelist, ',')
                              let close  = join(closelist, ',')
                              if exists("b:match_skip")
                                let skip = b:match_skip
                              elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" .. b:match_comment
                              else
                                let skip = 's:comment\|string'
                              endif
                              let skip = s:ParseSkip(skip)
                              let view = winsaveview()
                            
                              " Third step: call searchpair().
                              " Replace '\('--but not '\\('--with '\%(' and ',' with '\|'.
                              let openpat = substitute(open, '\%(' .. s:notslash .. '\)\@<=\\(', '\\%(', 'g')
                              let openpat = substitute(openpat, ',', '\\|', 'g')
                              let closepat = substitute(close, '\%(' .. s:notslash .. '\)\@<=\\(', '\\%(', 'g')
                              let closepat = substitute(closepat, ',', '\\|', 'g')
                              let middlepat = substitute(middle, '\%(' .. s:notslash .. '\)\@<=\\(', '\\%(', 'g')
                              let middlepat = substitute(middlepat, ',', '\\|', 'g')
                            
                              if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = '0'
                              else
                                try
                                  execute "if " .. skip .. "| let skip = '0' | endif"
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return {}
                                endtry
                              endif
                              mark '
                              while level
                                if searchpair(openpat, middlepat, closepat, a:spflag, skip) < 1
                                  call s:CleanUp(restore_options, a:mode, startpos)
                                  return {}
                                endif
                                let level = level - 1
                              endwhile
                            
                              " Restore options and return a string to restore the original position.
                              call s:CleanUp(restore_options, a:mode, startpos)
                              return view
                            endfun
                            
                            " Search backwards for "if" or "while" or "<tag>" or ...
                            " and return "endif" or "endwhile" or "</tag>" or ... .
                            " For now, this uses b:match_words and the same script variables
                            " as matchit#Match_wrapper() .  Later, it may get its own patterns,
                            " either from a buffer variable or passed as arguments.
                            " fun! s:Autocomplete()
                            "   echo "autocomplete not yet implemented :-("
                            "   if !exists("b:match_words") || b:match_words == ""
                            "     return ""
                            "   end
                            "   let startpos = matchit#MultiMatch("bW")
                            "
                            "   if startpos == ""
                            "     return ""
                            "   endif
                            "   " - TODO:  figure out whether 'if' or '<tag>' matched, and construct
                            "   " - the appropriate closing.
                            "   let matchline = getline(".")
                            "   let curcol = col(".") - 1
                            "   " - TODO:  Change the s:all argument if there is a new set of match pats.
                            "   let regexp = s:Wholematch(matchline, s:all, curcol)
                            "   let suf = strlen(matchline) - matchend(matchline, regexp)
                            "   let prefix = (curcol ? '^.\{'  . curcol . '}\%(' : '^\%(')
                            "   let suffix = (suf ? '\).\{' . suf . '}$'  : '\)$')
                            "   " Reconstruct the version with unresolved backrefs.
                            "   let patBR = substitute(b:match_words.',', '[,:]*,[,:]*', ',', 'g')
                            "   let patBR = substitute(patBR, ':\{2,}', ':', "g")
                            "   " Now, set group and groupBR to the matching group: 'if:endif' or
                            "   " 'while:endwhile' or whatever.
                            "   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)
                            "   let i = matchend(group, s:notslash . ",")
                            "   let groupBR = strpart(group, i)
                            "   let group = strpart(group, 0, i-1)
                            "   " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
                            "   if s:do_BR
                            "     let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
                            "   endif
                            " " let g:group = group
                            "
                            "   " - TODO:  Construct the closing from group.
                            "   let fake = "end" . expand("<cword>")
                            "   execute startpos
                            "   return fake
                            " endfun
                            
                            " Close all open structures.  "Get the heck out of here!"
                            " fun! s:Gthhoh()
                            "   let close = s:Autocomplete()
                            "   while strlen(close)
                            "     put=close
                            "     let close = s:Autocomplete()
                            "   endwhile
                            " endfun
                            
                            " Parse special strings as typical skip arguments for searchpair():
                            "   s:foo becomes (current syntax item) =~ foo
                            "   S:foo becomes (current syntax item) !~ foo
                            "   r:foo becomes (line before cursor) =~ foo
                            "   R:foo becomes (line before cursor) !~ foo
    1              0.000003 fun! s:ParseSkip(str)
                              let skip = a:str
                              if skip[1] == ":"
                                if skip[0] == "s"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') =~? '" ..
                                    \ strpart(skip,2) .. "'"
                                elseif skip[0] == "S"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') !~? '" ..
                                    \ strpart(skip,2) .. "'"
                                elseif skip[0] == "r"
                                  let skip = "strpart(getline('.'),0,col('.'))=~'" .. strpart(skip,2) .. "'"
                                elseif skip[0] == "R"
                                  let skip = "strpart(getline('.'),0,col('.'))!~'" .. strpart(skip,2) .. "'"
                                endif
                              endif
                              return skip
                            endfun
                            
    1   0.000074   0.000026 let &cpo = s:save_cpo
    1              0.000005 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:et:

SCRIPT  /home/david/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim
Sourced 1 time
Total time:   0.002757
 Self time:   0.002617

count  total (s)   self (s)
                            " =============================================================================
                            " File: wildfire.vim
                            " Description: Smart selection of the closest text object
                            " Mantainer: Giacomo Comitti (https://github.com/gcmt)
                            " Url: https://github.com/gcmt/wildfire.vim
                            " License: MIT
                            " =============================================================================
                            
                            
    1              0.000019 let s:save_cpo = &cpo
    1   0.000121   0.000026 set cpo&vim
                            
                            
                            " Internal variables
                            " =============================================================================
                            
    1              0.000013 let s:cannot_be_nested = {"iw" : 1, "aw" : 1, "iW" : 1, "aW": 1}
                            
    1              0.000004 let s:vim_text_objects = {}
   19              0.000071 for s:char in split("(){}[]<>'`\"bBwWpst", "\\zs")
   18              0.000172     let s:vim_text_objects = extend(s:vim_text_objects, {"a".s:char : 1, "i".s:char : 1})
   19              0.000020 endfor
                            
    1              0.000003 let s:counts = {}
    1              0.000003 let s:history = []
    1              0.000002 let s:origin = []
                            
                            
                            " Functions
                            " =============================================================================
                            
    1              0.000006 fu! wildfire#Start(repeat, objects)
                                cal s:init(a:objects)
                                cal wildfire#Fuel(a:repeat)
                            endfu
                            
    1              0.000003 fu! wildfire#Fuel(repeat)
                                for i in range(a:repeat)
                                    cal s:select_text_object()
                                endfor
                            endfu
                            
    1              0.000014 fu! wildfire#Water(repeat)
                                for i in range(a:repeat)
                                    cal setpos(".", s:origin)
                                    if len(s:history) > 1
                                        let s:counts[remove(s:history, -1).selection.object] -= 1
                                        cal winrestview(get(s:history, -1).view)
                                        cal s:select(get(s:history, -1).selection)
                                    endif
                                endfor
                            endfu
                            
    1              0.000004 fu! s:init(objects)
                                let s:origin = getpos(".")
                                let s:history = []
                                let s:counts = {}
                                let _objects = s:load_objects(a:objects)
                                for object in get(_objects, &ft, get(_objects, "*", []))
                                    let s:counts[object] = 1
                                endfor
                            endfu
                            
    1              0.000002 fu! s:load_objects(objects)
                                " force `a:objects` to be a dictionary
                                let _objects = type(a:objects) == type([]) ? {"*": a:objects} : a:objects
                                " split filetypes that share the same text objects
                                for [ftypes, objs] in items(_objects)
                                    for ft in split(ftypes, ",")
                                        let _objects[ft] = objs
                                    endfor
                                endfor
                                return _objects
                            endfu
                            
    1              0.000003 fu! s:select_text_object()
                            
                                cal setpos(".", s:origin)
                            
                                let view = winsaveview()
                            
                                let candidates = {}
                                for object in keys(s:counts)
                            
                                    let selection = {"object": object, "count": s:counts[object]}
                            
                                    let [startline, startcol, endline, endcol] = s:edges(selection)
                                    let selection = extend(selection,
                                        \ {"startline": startline, "startcol": startcol, "endline": endline, "endcol": endcol })
                            
                                    cal winrestview(view)
                            
                                    " Some text object cannot be nested. This avoids unwanted behavior.
                                    if get(s:cannot_be_nested, selection.object) && selection.count > 1
                                        continue
                                    endif
                            
                                    " The selection failed with the candidate text object
                                    if selection.startline == selection.endline && selection.startcol == selection.endcol
                                        continue
                                    endif
                            
                                    " Sometimes Vim selects text objects even if the cursor is outside the
                                    " them (e.g. `it`, `i"`, etc). We don't want this.
                                    if selection.startline == selection.endline
                                        if s:origin[2] < selection.startcol - 1 || s:origin[2] > selection.endcol + 1
                                            let s:counts[object] += 1
                                            continue
                                        endif
                                    endif
                            
                                    " Check if the cursor is even within selection. If not, we obviously
                                    " don't want that
                                    if s:origin[1] < selection.startline || s:origin[1] > selection.endline
                                        let s:counts[object] += 1
                                        continue
                                    endif
                            
                                    let size = s:size(selection)
                            
                                    " This happens when the _count is incremented but the selection remains still
                                    let _selection = extend(copy(selection), {"count": selection.count-1})
                                    if s:already_selected(_selection)
                                        continue
                                    endif
                            
                                    " Special case
                                    if object =~ "a\"\\|i\"\\|a'\\|i'" && startline == endline
                                        let _selection = extend(copy(selection),
                                            \ {"count": selection.count-1, "startcol": selection.startcol+1, "endcol": selection.endcol-1})
                                        if s:already_selected(_selection)
                                            " When there is no more string to select on the same line, vim
                                            " selects the outer string text object. This is far from the
                                            " desired behavior
                                            continue
                                        endif
                                        let _selection = extend(copy(selection),
                                            \ {"count": selection.count-1, "startcol": selection.startcol+1})
                                        if s:already_selected(_selection)
                                            " This follows the previous check. When the string ends the
                                            " line, the size of the text object is just one character less
                                            continue
                                        endif
                                        let line = getline("'<")
                                        let quote = strpart(object, 1)
                                        let [before, after] = [line[:selection.startcol-3], line[selection.endcol+1:]]
                                        if s:odd_quotes(quote, before) || s:odd_quotes(quote, after)
                                            continue
                                        endif
                                    endif
                            
                                    let candidates[size] = selection
                            
                                endfor
                            
                                cal s:select_best_candidate(candidates)
                            
                            endfu
                            
                            " To select the closest text object among the candidates
    1              0.000004 fu! s:select_best_candidate(candidates)
                                if len(a:candidates)
                                    " select the closest text object (the one with the smaller size)
                                    let selection = a:candidates[min(keys(a:candidates))]
                                    let s:history = add(s:history, {"selection": selection, "view": winsaveview()})
                                    let s:counts[selection.object] += 1
                                    cal s:select(selection)
                                elseif len(s:history)
                                    " get stuck on the last selection
                                    cal s:select(get(s:history, -1).selection)
                                else
                                    " do nothing
                                    exec "sil! norm! \<ESC>"
                                endif
                            endfu
                            
                            " To retrun the edges of a text object
    1              0.000002 fu! s:edges(selection)
                                cal s:select(a:selection)
                                exe "sil! norm! \<ESC>"
                                return [line("'<"), col("'<"), line("'>"), col("'>")]
                            endfu
                            
                            " To select a text object
    1              0.000002 fu! s:select(selection)
                                exe "sil! norm! \<ESC>v\<ESC>v"
                                if get(s:vim_text_objects, a:selection.object)
                                    " use counts when selecting vim text objects
                                    exe "sil! norm! " . a:selection.count . a:selection.object
                                else
                                    " counts might not be suported by non-default text objects
                                    for n in range(a:selection.count)
                                        exe "sil! norm " . a:selection.object
                                    endfor
                                endif
                            endfu
                            
                            " To check if a text object has been already selected
    1              0.000003 fu! s:already_selected(selection)
                                for s in s:history
                                    if s.selection == a:selection
                                        return 1
                                    end
                                endfor
                                return 0
                            endfu
                            
                            " To return the size of a text object
    1              0.000002 fu! s:size(selection)
                                if a:selection.startline == a:selection.endline
                                    return a:selection.endcol - a:selection.startcol + 1
                                endif
                                let size = len(getline(a:selection.startline)) - a:selection.startcol + a:selection.endcol + 1
                                let size += winwidth(0) * (a:selection.endline - a:selection.startline - 1)
                                return size
                            endfu
                            
                            " To check if in a strings there is an odd number of quotes
    1              0.000003 fu! s:odd_quotes(quote, s)
                                let n = 0
                                for i in range(0, strlen(a:s))
                                    if a:s[i] == a:quote && !(i > 0 && a:s[i-1] == "\\")
                                        let n += 1
                                    endif
                                endfor
                                return n % 2 != 0
                            endfu
                            
                            " Quick Select
                            " =============================================================================
                            
    1              0.000003 fu! wildfire#QuickSelect(objects)
                                cal s:init(a:objects)
                                while 1
                                    let last_hist_size = len(s:history)
                                    cal s:select_text_object()
                                    if empty(s:history)
                                        return
                                    end
                                    let selection = get(s:history, -1).selection
                                    if selection.startline < line("w0") || selection.endline > line("w$")
                                        cal wildfire#Water(1)
                                        break
                                    end
                                    if last_hist_size == len(s:history)
                                        break
                                    end
                                endw
                                exe "norm! \<ESC>"
                                cal setpos(".", s:origin)
                                let save_hl = s:turn_off_syntax_errs()
                                let marks = s:show_marks(map(copy(s:history), "v:val.selection"))
                                cal s:jump(marks)
                                cal s:turn_on_syntax_errs(save_hl)
                            endfu
                            
                            " To display marks
    1              0.000002 fu s:show_marks(selections)
                                try | undojoin | catch | endtry
                                cal matchadd("WildfireShade", '\%>'.(line('w0')-1).'l\%<'.line('w$').'l')
                                let marks = split(g:wildfire_marks, '\zs')
                                let placed_marks = {}
                                let candidates = {}
                                for selection in a:selections
                                    if empty(marks) | break | end
                                    if !has_key(placed_marks, selection.startline . "," . selection.startcol)
                                        let [mline, mcol] = [selection.startline, selection.startcol]
                                    elseif !has_key(placed_marks, selection.endline . "," . selection.endcol)
                                        let [mline, mcol] = [selection.endline, selection.endcol]
                                    else
                                        continue
                                    end
                                    let placed_marks[mline.",".mcol] = 1
                                    let mark = remove(marks, 0)
                                    let candidates[mark] = [
                                        \ selection,
                                        \ {"line": mline, "col": mcol, "char": mark, "oldchar": getline(mline)[mcol-1]}
                                    \ ]
                                    cal setline(mline, s:str_subst(getline(mline), mcol-1, mark))
                                    cal matchadd("WildfireMark", '\%'.mline.'l\%'.mcol.'c')
                                endfor
                                setl nomodified
                                return candidates
                            endfu
                            
                            " To ask the user where to jump and move there
    1              0.000002 fu s:jump(marks)
                                if empty(a:marks) | return | end
                                normal! m'
                                while 1
                                    redraw
                                    cal s:show_prompt()
                                    let choice = s:get_char()
                                    if choice =~ '<C-C>\|<ESC>'
                                        cal s:clear_marks(a:marks)
                                        break
                                    end
                                    if has_key(a:marks, choice)
                                        cal s:clear_marks(a:marks)
                                        cal s:select(a:marks[choice][0])
                                        let s:history = s:history[:stridx(g:wildfire_marks, choice)]
                                        break
                                    end
                                endw
                            endfu
                            
                            " To display the prompt
    1              0.000002 fu s:show_prompt()
                                echohl WildfirePrompt | echon g:wildfire_prompt | echohl None
                            endfu
                            
                            
                            " To clear all marks
    1              0.000002 fu s:clear_marks(marks)
                                cal s:clear_matches("WildfireMark", "WildfireShade")
                                try | undojoin | catch | endtry
                                for [s, mark] in values(a:marks)
                                    cal setline(mark.line, s:str_subst(getline(mark.line), mark.col-1, mark.oldchar))
                                endfor
                                setl nomodified
                            endfu
                            
                            " To turn off syntax errors. The returned value can be used to restore syntax
                            " errors with s:turn_on_syntax_err()
    1              0.000003 fu s:turn_off_syntax_errs()
                                let colors = s:colors_of("Error")
                                hi Error None
                                return colors
                            endfu
                            
                            " To turn on syntax errors
    1              0.000003 fu s:turn_on_syntax_errs(colors)
                                cal s:set_colors("Error", a:colors)
                            endfu
                            
                            " Utilities
                            " =============================================================================
                            
                            " To get the colors of given highlight group.
    1              0.000002 fu s:colors_of(group)
                                redir => raw_hl
                                    exe "hi" a:group
                                redir END
                                let raw_hl = substitute(raw_hl, "\n", " ", "")
                                if match(raw_hl, 'cleared') >= 0
                                    return {"colors": "None", "link": ""}
                                end
                                if match(raw_hl, "links to") >= 0
                                    return {"colors": "", "link": matchstr(raw_hl, '\v(links to )@<=.*')}
                                end
                                return {"colors": matchstr(raw_hl, '\v( xxx )@<=.*'), "link": ""}
                            endfu
                            
                            " To set the colors for a given highlight group. Note that this function should
                            " be used exclusively with colors retrieved with the function s:color_of(..)
    1              0.000003 fu s:set_colors(group, colors)
                                if !empty(a:colors.link)
                                    exe "hi link" a:group a:colors.link
                                else
                                    exe "hi" a:group a:colors.colors
                                end
                            endfu
                            
                            " To clear matches of given groups
    1              0.000002 fu s:clear_matches(...)
                                for m in getmatches()
                                    if index(a:000, m.group) != -1
                                        cal matchdelete(m.id)
                                    end
                                endfor
                            endfu
                            
                            " To substitute a character in a string
    1              0.000003 fu s:str_subst(str, col, char)
                                return strpart(a:str, 0, a:col) . a:char . strpart(a:str, a:col+1)
                            endfu
                            
                            " To get a key pressed by the user
    1              0.000002 fu s:get_char()
                                let char = strtrans(getchar())
                                    if char == 13 | return "<CR>"
                                elseif char == 27 | return "<ESC>"
                                elseif char == 9 | return "<TAB>"
                                elseif char >= 1 && char <= 26 | return "<C-" . nr2char(char+64) . ">"
                                elseif char != 0 | return nr2char(char)
                                elseif match(char, '<fc>^D') > 0 | return "<C-SPACE>"
                                elseif match(char, 'kb') > 0 | return "<BS>"
                                elseif match(char, 'ku') > 0 | return "<UP>"
                                elseif match(char, 'kd') > 0 | return "<DOWN>"
                                elseif match(char, 'kl') > 0 | return "<LEFT>"
                                elseif match(char, 'kr') > 0 | return "<RIGHT>"
                                elseif match(char, 'k\\d\\+') > 0 | return "<F" . match(char, '\\d\\+', 4) . ">"
                                end
                            endfu
                            
                            " =============================================================================
                            
    1   0.000076   0.000031 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo

SCRIPT  /home/david/.local/share/nvim/lazy/fcitx.vim/plugin/fcitx.vim
Sourced 1 time
Total time:   0.287182
 Self time:   0.003117

count  total (s)   self (s)
    1              0.000039 scriptencoding utf-8
                            " fcitx.vim	remember fcitx's input state for each buffer
                            " Author:       lilydjwg
                            " Version:	2.0a
                            " URL:		https://www.vim.org/scripts/script.php?script_id=3764
                            " ---------------------------------------------------------------------
                            " Load Once:
    1              0.000115 if &cp || exists("g:loaded_fcitx") || (!exists('$DISPLAY') && !exists('$WAYLAND_DISPLAY'))
                              finish
    1              0.000005 endif
    1              0.000061 let s:keepcpo = &cpo
    1              0.000094 set cpo&vim
                            
    1              0.000029 function s:setup_cmd()
                              function Fcitx2en()
                                let inputstatus = trim(system(g:fcitx5_remote))
                                if inputstatus == '2'
                                  let b:inputtoggle = 1
                                  call system(g:fcitx5_remote . ' -c')
                                endif
                              endfunction
                              function Fcitx2zh()
                                try
                                  if b:inputtoggle == 1
                                    call system(g:fcitx5_remote . ' -o')
                                    let b:inputtoggle = 0
                                  endif
                                catch /inputtoggle/
                                  let b:inputtoggle = 0
                                endtry
                              endfunction
                            
                              let g:loaded_fcitx = 1
                            endfunction
                            
                            " If g:fcitx5_remote is set (to the path to `fcitx5-remove`), use it to toggle IME state.
    1              0.000013 if exists("g:fcitx5_remote")
                              call s:setup_cmd()
                            
                            " Otherwise, if python3 is available, use python and dbus to toggle IME state.
    1              0.000017 elseif has('python3')
    1              0.000003   try " abort on fail
    1   0.283569   0.000154     exe 'py3file' expand('<sfile>:r') . '.py'
    1   0.000783   0.000134     if py3eval('fcitx_loaded')
    1              0.000039       function Fcitx2en()
                                    py3 fcitx2en()
                                  endfunction
    1              0.000004       function Fcitx2zh()
                                    py3 fcitx2zh()
                                  endfunction
    1              0.000002       function FcitxCurrentIM()
                                    return py3eval('fcitx_current_im()')
                                  endfunction
                            
    1              0.000016       let g:loaded_fcitx = 1
    1              0.000003     endif
                              catch
                                if executable('fcitx5-remote')
                                  let g:fcitx5_remote = 'fcitx5-remote'
                                  call s:setup_cmd()
                                endif
    1              0.000002   endtry
    1              0.000002 endif
                            
                            " Register autocmd if successfully loaded.
    1              0.000009 if exists("g:loaded_fcitx")
    1              0.000009   if exists('##InsertLeavePre')
    1              0.000029     au InsertLeavePre * call Fcitx2en()
                              else
                                au InsertLeave * call Fcitx2en()
    1              0.000001   endif
    1              0.000009   au InsertEnter * call Fcitx2zh()
    1              0.000016   au CmdlineEnter [/\?] call Fcitx2zh()
    1              0.000012   au CmdlineLeave [/\?] call Fcitx2en()
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines:
    1              0.000069 let &cpo=s:keepcpo
    1              0.000011 unlet s:keepcpo
                            
                            " vim: sw=2 :

SCRIPT  /usr/share/nvim/runtime/autoload/provider.vim
Sourced 1 time
Total time:   0.001895
 Self time:   0.001895

count  total (s)   self (s)
                            " Common functions for providers
                            
                            " Start the provider and perform a 'poll' request
                            "
                            " Returns a valid channel on success
    1              0.000028 function! provider#Poll(argv, orig_name, log_env, ...) abort
                              let job = {'rpc': v:true, 'stderr_buffered': v:true}
                              if a:0
                                let job = extend(job, a:1)
                              endif
                              try
                                let channel_id = jobstart(a:argv, job)
                                if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
                                  return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in get(job, 'stderr', [])
                                  echomsg row
                                endfor
                              endtry
                              throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)
                            endfunction

SCRIPT  /home/david/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim
Sourced 1 time
Total time:   0.133945
 Self time:   0.002700

count  total (s)   self (s)
    1              0.000085 if exists("b:did_autoload_ultisnips")
                                finish
    1              0.000006 endif
    1              0.000029 let b:did_autoload_ultisnips = 1
                            
                            " Also import vim as we expect it to be imported in many places.
    1   0.001974   0.000180 py3 import vim
    1   0.129509   0.000058 py3 from UltiSnips import UltiSnips_Manager
                            
    1              0.000010 function! s:compensate_for_pum() abort
                                """ The CursorMovedI event is not triggered while the popup-menu is visible,
                                """ and it's by this event that UltiSnips updates its vim-state. The fix is
                                """ to explicitly check for the presence of the popup menu, and update
                                """ the vim-state accordingly.
                                if pumvisible()
                                    py3 UltiSnips_Manager._cursor_moved()
                                endif
                            endfunction
                            
    1              0.000004 function! s:is_floating(winId) abort
                                if has('nvim')
                                    return get(nvim_win_get_config(a:winId), 'relative', '') !=# ''
                                endif
                            
                                return 0
                            endfunction
                            
    1              0.000004 function! UltiSnips#Edit(bang, ...) abort
                                if a:0 == 1 && a:1 != ''
                                    let type = a:1
                                else
                                    let type = ""
                                endif
                                py3 vim.command("let file = '%s'" % UltiSnips_Manager._file_to_edit(vim.eval("type"), vim.eval('a:bang')))
                            
                                if !len(file)
                                   return
                                endif
                            
                                let mode = 'e'
                                if exists('g:UltiSnipsEditSplit')
                                    if g:UltiSnipsEditSplit == 'vertical'
                                        let mode = 'vs'
                                    elseif g:UltiSnipsEditSplit == 'horizontal'
                                        let mode = 'sp'
                                    elseif g:UltiSnipsEditSplit == 'tabdo'
                                        let mode = 'tabedit'
                                    elseif g:UltiSnipsEditSplit == 'context'
                                        let mode = 'vs'
                                        if winwidth(0) <= 2 * (&tw ? &tw : 80)
                                            let mode = 'sp'
                                        endif
                                    endif
                                endif
                                exe ':'.mode.' '.escape(file, ' ')
                            endfunction
                            
    1              0.000003 function! UltiSnips#AddFiletypes(filetypes) abort
                                py3 UltiSnips_Manager.add_buffer_filetypes(vim.eval("a:filetypes"))
                                return ""
                            endfunction
                            
    1              0.000004 function! UltiSnips#FileTypeComplete(arglead, cmdline, cursorpos) abort
                                let ret = {}
                                let items = map(
                                \   split(globpath(&runtimepath, 'syntax/*.vim'), '\n'),
                                \   'fnamemodify(v:val, ":t:r")'
                                \ )
                                call insert(items, 'all')
                                for item in items
                                    if !has_key(ret, item) && item =~ '^'.a:arglead
                                        let ret[item] = 1
                                    endif
                                endfor
                            
                                return sort(keys(ret))
                            endfunction
                            
    1              0.000003 function! UltiSnips#ExpandSnippet() abort
                                py3 UltiSnips_Manager.expand()
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#ExpandSnippetOrJump() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.expand_or_jump()
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#ListSnippets() abort
                                py3 UltiSnips_Manager.list_snippets()
                                return ""
                            endfunction
                            
    1              0.000003 function! UltiSnips#SnippetsInCurrentScope(...) abort
                                let g:current_ulti_dict = {}
                                let all = get(a:, 1, 0)
                                if all
                                  let g:current_ulti_dict_info = {}
                                endif
                                py3 UltiSnips_Manager.snippets_in_current_scope(int(vim.eval("all")))
                                return g:current_ulti_dict
                            endfunction
                            
    1              0.000002 function! UltiSnips#CanExpandSnippet() abort
                            	py3 vim.command("let can_expand = %d" % UltiSnips_Manager.can_expand())
                            	return can_expand
                            endfunction
                            
    1              0.000002 function! UltiSnips#CanJumpForwards() abort
                            	py3 vim.command("let can_jump_forwards = %d" % UltiSnips_Manager.can_jump_forwards())
                            	return can_jump_forwards
                            endfunction
                            
    1              0.000002 function! UltiSnips#CanJumpBackwards() abort
                            	py3 vim.command("let can_jump_backwards = %d" % UltiSnips_Manager.can_jump_backwards())
                            	return can_jump_backwards
                            endfunction
                            
    1              0.000003 function! UltiSnips#SaveLastVisualSelection() range abort
                                py3 UltiSnips_Manager._save_last_visual_selection()
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#JumpBackwards() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_backwards()
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#JumpForwards() abort
                                call s:compensate_for_pum()
                                py3 UltiSnips_Manager.jump_forwards()
                                return ""
                            endfunction
                            
    1              0.000006 function! UltiSnips#AddSnippetWithPriority(trigger, value, description, options, filetype, priority) abort
                                py3 trigger = vim.eval("a:trigger")
                                py3 value = vim.eval("a:value")
                                py3 description = vim.eval("a:description")
                                py3 options = vim.eval("a:options")
                                py3 filetype = vim.eval("a:filetype")
                                py3 priority = vim.eval("a:priority")
                                py3 UltiSnips_Manager.add_snippet(trigger, value, description, options, filetype, priority)
                                return ""
                            endfunction
                            
    1              0.000003 function! UltiSnips#Anon(value, ...) abort
                                " Takes the same arguments as SnippetManager.expand_anon:
                                " (value, trigger="", description="", options="")
                                py3 args = vim.eval("a:000")
                                py3 value = vim.eval("a:value")
                                py3 UltiSnips_Manager.expand_anon(value, *args)
                                return ""
                            endfunction
                            
    1              0.000002 function! UltiSnips#CursorMoved() abort
                                py3 UltiSnips_Manager._cursor_moved()
                            endf
                            
    1              0.000002 function! UltiSnips#LeavingBuffer() abort
                                let from_preview = getwinvar(winnr('#'), '&previewwindow')
                                let to_preview = getwinvar(winnr(), '&previewwindow')
                                let from_floating = s:is_floating(win_getid('#'))
                                let to_floating = s:is_floating(win_getid())
                            
                                if !(from_preview || to_preview || from_floating || to_floating)
                                    py3 UltiSnips_Manager._leaving_buffer()
                                endif
                            endf
                            
    1              0.000002 function! UltiSnips#LeavingInsertMode() abort
                                py3 UltiSnips_Manager._leaving_insert_mode()
                            endfunction
                            
    1              0.000002 function! UltiSnips#TrackChange() abort
                                py3 UltiSnips_Manager._track_change()
                            endfunction
                            
    1              0.000002 function! UltiSnips#RefreshSnippets() abort
                                py3 UltiSnips_Manager._refresh_snippets()
                            endfunction
                            " }}}

FUNCTION  <SNR>12_vm_persist()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/plugin/visual-multi.vim:76
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000008   if exists('g:VM_PERSIST') && !g:VM_persistent_registers
                                unlet g:VM_PERSIST
    1              0.000002   elseif g:VM_persistent_registers
                                let g:VM_PERSIST = deepcopy(g:Vm.registers)
    1              0.000001   endif

FUNCTION  <SNR>57_activate()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:91
Called 12 times
Total time:   0.002778
 Self time:   0.002778

count  total (s)   self (s)
   12              0.000297   if index(g:rooter_buftypes, &buftype) == -1 | return 0 | endif
                            
   12              0.000262   let patterns = split(g:rooter_targets, ',')
   12              0.000495   let fn = expand('%:p', 1)
                            
   12              0.000380   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
                            
                              " directory
   12              0.000124   if empty(fn) || fn[-1:] == '/'
                                return index(patterns, '/') != -1
   12              0.000015   endif
                            
                              " file
   12              0.000304   if !filereadable(fn) | return 0 | endif
   12              0.000113   if !exists('*glob2regpat') | return 1 | endif
                            
   12              0.000277   for p in filter(copy(patterns), 'v:val != "/"')
   12              0.000261     if fn =~ glob2regpat(p)
   12              0.000036       return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  cmp_nvim_ultisnips#get_current_snippets()
    Defined: ~/.local/share/nvim/lazy/cmp-nvim-ultisnips/autoload/cmp_nvim_ultisnips.vim:9
Called 60 times
Total time:   0.694500
 Self time:   0.694500

count  total (s)   self (s)
   60              0.000943 let g:_cmpu_current_snippets = []
   60              0.000301 python3 << EOF
                            import vim
                            from UltiSnips import UltiSnips_Manager, vim_helper
                            
                            before = vim_helper.buf.line_till_cursor
                            visual_content = UltiSnips_Manager._visual_content
                            expandable_only = vim.eval("a:expandable_only") == "True"
                            if expandable_only:
                                snippets = UltiSnips_Manager._snips(before, True)
                            else:
                                snippets = UltiSnips_Manager._snips("", True)
                            
                            for snippet in snippets:
                                is_context_snippet = snippet._context_code != None
                                is_regex_snippet = "r" in snippet._opts
                                # If show_snippets == "all", the snippets are cached so ignore "dynamic" snippets.
                                if not expandable_only and (is_context_snippet or is_regex_snippet):
                                  continue
                                # For custom context snippets, always check if the context matches.
                                if is_context_snippet and not snippet._context_match(visual_content, before):
                                    continue
                            
                                vim.command(
                                  "call add(g:_cmpu_current_snippets, {"
                                  "'trigger': py3eval('snippet._trigger'),"
                                  "'description': py3eval('snippet._description'),"
                                  "'options': py3eval('snippet._opts'),"
                                  "'value': py3eval('snippet._value'),"
                                  "'matched': py3eval('snippet._matched'),"
                                  "})"
                                )
                            EOF
   60              0.000731 return g:_cmpu_current_snippets

FUNCTION  copilot#agent#LspHandle()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:387
Called 155 times
Total time:   0.037675
 Self time:   0.009403

count  total (s)   self (s)
  155              0.003779   if !has_key(s:instances, a:agent_id)
                                return
  155              0.000297   endif
  155   0.032576   0.004304   call s:OnResponse(s:instances[a:agent_id], a:response)

FUNCTION  <SNR>92_AddEval()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim:278
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000004   if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
    1              0.000001   endif

FUNCTION  copilot#doc#Params()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/doc.vim:74
Called 87 times
Total time:   0.041447
 Self time:   0.007571

count  total (s)   self (s)
   87              0.000971   let extra = a:0 ? a:1 : {}
   87   0.038042   0.004165   let params = extend({'doc': extend(copilot#doc#Get(), get(extra, 'doc', {}))}, extra, 'keep')
   87              0.001317   let params.textDocument = { 'uri': params.doc.uri, 'version': params.doc.version, 'relativePath': params.doc.relativePath, }
   87              0.000421   let params.position = params.doc.position
   87              0.000225   return params

FUNCTION  copilot#IsMapped()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:434
Called 25 times
Total time:   0.001178
 Self time:   0.001178

count  total (s)   self (s)
   25              0.001079   return get(g:, 'copilot_assume_mapped') || hasmapto('copilot#Accept(', 'i')

FUNCTION  copilot#agent#Cancel()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:542
Called 174 times
Total time:   0.017992
 Self time:   0.003678

count  total (s)   self (s)
  174              0.001787   if type(a:request) == type({}) && has_key(a:request, 'Cancel')
   87   0.015496   0.001182     call a:request.Cancel()
  174              0.000174   endif

FUNCTION  <SNR>23_Trigger()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:425
Called 87 times
Total time:   0.192417
 Self time:   0.008971

count  total (s)   self (s)
   87              0.003385   let timer = get(g:, '_copilot_timer', -1)
   87              0.000626   unlet! g:_copilot_timer
   87              0.001874   if a:bufnr !=# bufnr('') || a:timer isnot# timer || mode() !=# 'i'
                                return
   87              0.000222   endif
   87   0.185411   0.001965   return copilot#Suggest()

FUNCTION  <SNR>132_Resolve()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:470
Called 11 times
Total time:   0.002601
 Self time:   0.001968

count  total (s)   self (s)
   11              0.000064   let word = a:target
   11              0.000206   let i = matchend(word, s:notslash .. '\\\d') - 1
   11              0.000030   let table = "----------"
   12              0.000043   while i != -2 " There are back references to be replaced.
    1              0.000009     let d = word[i]
    1   0.000264   0.000027     let backref = s:Ref(a:source, d)
                                " The idea is to replace '\d' with backref.  Before we do this,
                                " replace any \(\) groups in backref with :1, :2, ... if they
                                " correspond to the first, second, ... group already inserted
                                " into backref.  Later, replace :1 with \1 and so on.  The group
                                " number w+b within backref corresponds to the group number
                                " s within a:source.
                                " w = number of '\(' in word before the current one
    1   0.000128   0.000046     let w = s:Count( substitute(strpart(word, 0, i-1), '\\\\', '', 'g'), '\(', '1')
    1              0.000003     let b = 1 " number of the current '\(' in backref
    1              0.000003     let s = d " number of the current '\(' in a:source
    2   0.000383   0.000069     while b <= s:Count(substitute(backref, '\\\\', '', 'g'), '\(', '1') && s < 10
    1              0.000006       if table[s] == "-"
    1              0.000002         if w + b < 10
                                      " let table[s] = w + b
    1              0.000011           let table = strpart(table, 0, s) .. (w+b) .. strpart(table, s+1)
    1              0.000001         endif
    1              0.000002         let b = b + 1
    1              0.000003         let s = s + 1
                                  else
                                    execute s:Ref(backref, b, "start", "len")
                                    let ref = strpart(backref, start, len)
                                    let backref = strpart(backref, 0, start) .. ":" .. table[s] .. strpart(backref, start+len)
                                    let s = s + s:Count(substitute(ref, '\\\\', '', 'g'), '\(', '1')
    1              0.000001       endif
    2              0.000002     endwhile
    1              0.000012     let word = strpart(word, 0, i-1) .. backref .. strpart(word, i+1)
    1              0.000032     let i = matchend(word, s:notslash .. '\\\d') - 1
   12              0.000071   endwhile
   11              0.000218   let word = substitute(word, s:notslash .. '\zs:', '\\', 'g')
   11              0.000045   if a:output == "table"
                                return table
   11              0.000028   elseif a:output == "word"
   11              0.000022     return word
                              else
                                return table .. word
                              endif

FUNCTION  <SNR>23_SuggestionTextWithAdjustments()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:193
Called 188 times
Total time:   0.033127
 Self time:   0.031953

count  total (s)   self (s)
  188              0.000291   try
  188   0.008726   0.007552     if mode() !~# '^[iR]' || (s:HideDuringCompletion() && pumvisible()) || !s:dest || !exists('b:_copilot.suggestions')
   78              0.000583       return ['', 0, 0, '']
  110              0.000105     endif
  110              0.000897     let choice = get(b:_copilot.suggestions, b:_copilot.choice, {})
  110              0.000779     if !has_key(choice, 'range') || choice.range.start.line != line('.') - 1
  107              0.000492       return ['', 0, 0, '']
    3              0.000003     endif
    3              0.000015     let line = getline('.')
    3              0.000018     let offset = col('.') - 1
    3              0.000009     if choice.range.start.character != 0
                                  call copilot#logger#Warn('unexpected range ' . json_encode(choice.range))
                                  return ['', 0, 0, '']
    3              0.000002     endif
    3              0.000021     let typed = strpart(line, 0, offset)
    3              0.000014     if exists('*utf16idx')
    3              0.000023       let end_offset = byteidx(line, choice.range.end.character, 1)
                                elseif has('nvim')
                                  let end_offset = v:lua.vim.str_byteindex(line, choice.range.end.character, 1)
                                else
                                  let end_offset = len(line)
                                  while copilot#doc#UTF16Width(strpart(line, 0, end_offset)) > choice.range.end.character && end_offset > 0
                                    let end_offset -= 1
                                  endwhile
    3              0.000003     endif
    3              0.000019     let delete = strpart(line, offset, end_offset - offset)
    3              0.000016     let uuid = get(choice, 'uuid', '')
    3              0.000032     if typed =~# '^\s*$'
                                  let leading = matchstr(choice.text, '^\s\+')
                                  let unindented = strpart(choice.text, len(leading))
                                  if strpart(typed, 0, len(leading)) == leading && unindented !=# delete
                                    return [unindented, len(typed) - len(leading), strchars(delete), uuid]
                                  endif
    3              0.000024     elseif typed ==# strpart(choice.text, 0, offset)
    3              0.000036       return [strpart(choice.text, offset), 0, strchars(delete), uuid]
                                endif
                              catch
                                call copilot#logger#Exception()
  188              0.000387   endtry
                              return ['', 0, 0, '']

FUNCTION  <SNR>133_edges()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:178
Called 28 times
Total time:   0.096681
 Self time:   0.002156

count  total (s)   self (s)
   28   0.088934   0.000478     cal s:select(a:selection)
   28   0.007072   0.001004     exe "sil! norm! \<ESC>"
   28              0.000501     return [line("'<"), col("'<"), line("'>"), col("'>")]

FUNCTION  <SNR>87_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:39
Called 1107 times
Total time:   0.251470
 Self time:   0.220638

count  total (s)   self (s)
                              " Remove any previous match.
 1107   0.049265   0.018432   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
 1107              0.011498   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
 1107              0.001090   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
 1107              0.007729   let c_lnum = line('.')
 1107              0.005646   let c_col = col('.')
 1107              0.002654   let before = 0
                            
 1107              0.005708   let text = getline(c_lnum)
 1107              0.038279   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
 1107              0.007356   if empty(matches)
                                let [c_before, c] = ['', '']
 1107              0.001534   else
 1107              0.009880     let [c_before, c] = matches[1:2]
 1107              0.001369   endif
 1107              0.026932   let plist = split(&matchpairs, '.\zs[:,]')
 1107              0.007565   let i = index(plist, c)
 1107              0.003045   if i < 0
                                " not found, in Insert mode try character before the cursor
 1075              0.008993     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  147              0.000709       let before = strlen(c_before)
  147              0.000338       let c = c_before
  147              0.000553       let i = index(plist, c)
 1075              0.001217     endif
 1075              0.002182     if i < 0
                                  " not found, nothing to do
 1071              0.002469       return
    4              0.000007     endif
   36              0.000032   endif
                            
                              " Figure out the arguments for searchpairpos().
   36              0.000087   if i % 2 == 0
   14              0.000031     let s_flags = 'nW'
   14              0.000071     let c2 = plist[i + 1]
   22              0.000021   else
   22              0.000057     let s_flags = 'nbW'
   22              0.000065     let c2 = c
   22              0.000098     let c = plist[i - 1]
   36              0.000032   endif
   36              0.000100   if c == '['
    3              0.000010     let c = '\['
    3              0.000011     let c2 = '\]'
   36              0.000028   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   36              0.000072   if before > 0
    4              0.000044     let has_getcurpos = exists("*getcurpos")
    4              0.000015     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    4              0.000038       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
    4              0.000007     endif
    4              0.000047     call cursor(c_lnum, c_col - before)
   36              0.000029   endif
                            
   36              0.000367   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   36              0.000036   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
   36              0.000266     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   36              0.000062     try
   36              0.001308       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   36              0.000053     endtry
   36              0.000032   endif
                            
                              " Limit the search to lines visible in the window.
   36              0.000212   let stoplinebottom = line('w$')
   36              0.000144   let stoplinetop = line('w0')
   36              0.000080   if i % 2 == 0
   14              0.000066     let stopline = stoplinebottom
   22              0.000021   else
   22              0.000099     let stopline = stoplinetop
   36              0.000031   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   36              0.000182   if mode() == 'i' || mode() == 'R'
   10              0.000109     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   26              0.000020   else
   26              0.000183     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   36              0.000033   endif
   36              0.000045   try
   36              0.009888     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   36              0.000056   endtry
                            
   36              0.000089   if before > 0
    4              0.000011     if has_getcurpos
    4              0.000038       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
    4              0.000005     endif
   36              0.000029   endif
                            
                              " If a match is found setup match highlighting.
   36              0.000185   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   29              0.000128     if exists('*matchaddpos')
   29              0.000420       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   29              0.000023     endif
   29              0.000087     let w:paren_hl_on = 1
   36              0.000033   endif

FUNCTION  copilot#OnCursorMovedI()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:473
Called 73 times
Total time:   0.063678
 Self time:   0.000958

count  total (s)   self (s)
   73   0.063571   0.000851   return copilot#Schedule()

FUNCTION  remote#host#Require()
    Defined: /usr/share/nvim/runtime/autoload/remote/host.vim:33
Called 2 times
Total time:   0.828992
 Self time:   0.000282

count  total (s)   self (s)
    2              0.000031   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
    2              0.000003   endif
    2              0.000018   let host = s:hosts[a:name]
    2              0.000010   if !host.channel && !host.initialized
    2              0.000036     let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
    2   0.828844   0.000134     let host.channel = call(host.factory, [host_info])
    2              0.000010     let host.initialized = 1
    2              0.000002   endif
    2              0.000012   return host.channel

FUNCTION  copilot#agent#Error()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:563
Called 87 times
Total time:   0.002481
 Self time:   0.002481

count  total (s)   self (s)
   87              0.000683   if has_key(a:request, 'reject')
   87              0.000725     call add(a:request.reject, a:callback)
                              elseif has_key(a:request, 'error')
                                let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'error', a:callback]))] = 1
   87              0.000090   endif

FUNCTION  <SNR>23_HideDuringCompletion()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:189
Called 138 times
Total time:   0.001174
 Self time:   0.001174

count  total (s)   self (s)
  138              0.000993   return get(g:, 'copilot_hide_during_completion', 1)

FUNCTION  copilot#doc#UTF16Width()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/doc.vim:10
Called 87 times
Total time:   0.002431
 Self time:   0.002431

count  total (s)   self (s)
   87              0.002247   return strchars(substitute(a:str, "\\%#=2[^\u0001-\uffff]", "  ", 'g'))

FUNCTION  <SNR>133_already_selected()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:199
Called 20 times
Total time:   0.000359
 Self time:   0.000359

count  total (s)   self (s)
   20              0.000117     for s in s:history
                                    if s.selection == a:selection
                                        return 1
                                    end
   20              0.000034     endfor
   20              0.000042     return 0

FUNCTION  <SNR>57_parent()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:220
Called 24 times
Total time:   0.000209
 Self time:   0.000209

count  total (s)   self (s)
   24              0.000182   return fnamemodify(a:dir, ':h')

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:14
Called 10 times
Total time:   0.063459
 Self time:   0.063459

count  total (s)   self (s)
   10              0.000106     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
   10              0.000015     endif
                            
   10              0.000080     let s = expand("<amatch>")
   10              0.000034     if s != ""
   10              0.000175       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
   10              0.000010       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   20              0.000172       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
   10              0.062467         exe printf('runtime! ftplugin/%s.vim ftplugin/%s.lua ftplugin/%s_*.vim ftplugin/%s_*.lua ftplugin/%s/*.vim ftplugin/%s/*.lua', name, name, name, name, name, name)
   20              0.000070       endfor
   10              0.000016     endif

FUNCTION  provider#python3#Call()
    Defined: /usr/share/nvim/runtime/autoload/provider/python3.vim:26
Called 341 times
Total time:   2.307317
 Self time:   2.048868

count  total (s)   self (s)
  341              0.003274   if s:err != ''
                                return
  341              0.000609   endif
  341              0.002677   if !exists('s:host')
    1              0.000046     let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
    1              0.000005     try
    1   0.258536   0.000088       let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
    1              0.000004     endtry
  341              0.000320   endif
  341              2.029548   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  <SNR>133_load_objects()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:64
Called 4 times
Total time:   0.000470
 Self time:   0.000470

count  total (s)   self (s)
                                " force `a:objects` to be a dictionary
    4              0.000086     let _objects = type(a:objects) == type([]) ? {"*": a:objects} : a:objects
                                " split filetypes that share the same text objects
    8              0.000079     for [ftypes, objs] in items(_objects)
    8              0.000092         for ft in split(ftypes, ",")
    4              0.000035             let _objects[ft] = objs
    8              0.000025         endfor
    8              0.000016     endfor
    4              0.000027     return _objects

FUNCTION  <SNR>132_ParseSkip()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:756
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000003   let skip = a:str
    1              0.000002   if skip[1] == ":"
    1              0.000002     if skip[0] == "s"
    1              0.000004       let skip = "synIDattr(synID(line('.'),col('.'),1),'name') =~? '" .. strpart(skip,2) .. "'"
                                elseif skip[0] == "S"
                                  let skip = "synIDattr(synID(line('.'),col('.'),1),'name') !~? '" .. strpart(skip,2) .. "'"
                                elseif skip[0] == "r"
                                  let skip = "strpart(getline('.'),0,col('.'))=~'" .. strpart(skip,2) .. "'"
                                elseif skip[0] == "R"
                                  let skip = "strpart(getline('.'),0,col('.'))!~'" .. strpart(skip,2) .. "'"
    1              0.000001     endif
    1              0.000001   endif
    1              0.000002   return skip

FUNCTION  Fcitx2zh()
    Defined: ~/.local/share/nvim/lazy/fcitx.vim/plugin/fcitx.vim:48
Called 24 times
Total time:   0.031415
 Self time:   0.031415

count  total (s)   self (s)
   24              0.031330         py3 fcitx2zh()

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:13
Called 10 times
Total time:   0.010929
 Self time:   0.010929

count  total (s)   self (s)
   10              0.000076     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
   10              0.000010     endif
   10              0.000071     let s = expand("<amatch>")
   10              0.000034     if s != ""
   10              0.000033       if exists("b:did_indent")
                            	unlet b:did_indent
   10              0.000016       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   20              0.000111       for name in split(s, '\.')
   10              0.005357         exe 'runtime! indent/' . name . '.vim'
   10              0.004998         exe 'runtime! indent/' . name . '.lua'
   20              0.000034       endfor
   10              0.000012     endif

FUNCTION  <SNR>133_select_text_object()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:76
Called 4 times
Total time:   0.111265
 Self time:   0.006604

count  total (s)   self (s)
                            
    4              0.000045     cal setpos(".", s:origin)
                            
    4              0.000050     let view = winsaveview()
                            
    4              0.000016     let candidates = {}
   32              0.000142     for object in keys(s:counts)
                            
   28              0.000323         let selection = {"object": object, "count": s:counts[object]}
                            
   28   0.097377   0.000696         let [startline, startcol, endline, endcol] = s:edges(selection)
   28              0.000643         let selection = extend(selection, {"startline": startline, "startcol": startcol, "endline": endline, "endcol": endcol })
                            
   28              0.000293         cal winrestview(view)
                            
                                    " Some text object cannot be nested. This avoids unwanted behavior.
   28              0.000300         if get(s:cannot_be_nested, selection.object) && selection.count > 1
                                        continue
   28              0.000035         endif
                            
                                    " The selection failed with the candidate text object
   28              0.000186         if selection.startline == selection.endline && selection.startcol == selection.endcol
    8              0.000019             continue
   20              0.000018         endif
                            
                                    " Sometimes Vim selects text objects even if the cursor is outside the
                                    " them (e.g. `it`, `i"`, etc). We don't want this.
   20              0.000075         if selection.startline == selection.endline
   16              0.000156             if s:origin[2] < selection.startcol - 1 || s:origin[2] > selection.endcol + 1
    8              0.000052                 let s:counts[object] += 1
    8              0.000020                 continue
    8              0.000009             endif
   12              0.000011         endif
                            
                                    " Check if the cursor is even within selection. If not, we obviously
                                    " don't want that
   12              0.000083         if s:origin[1] < selection.startline || s:origin[1] > selection.endline
                                        let s:counts[object] += 1
                                        continue
   12              0.000010         endif
                            
   12   0.000487   0.000236         let size = s:size(selection)
                            
                                    " This happens when the _count is incremented but the selection remains still
   12              0.000257         let _selection = extend(copy(selection), {"count": selection.count-1})
   12   0.000425   0.000200         if s:already_selected(_selection)
                                        continue
   12              0.000012         endif
                            
                                    " Special case
   12              0.000229         if object =~ "a\"\\|i\"\\|a'\\|i'" && startline == endline
    4              0.000102             let _selection = extend(copy(selection), {"count": selection.count-1, "startcol": selection.startcol+1, "endcol": selection.endcol-1})
    4   0.000143   0.000069             if s:already_selected(_selection)
                                            " When there is no more string to select on the same line, vim
                                            " selects the outer string text object. This is far from the
                                            " desired behavior
                                            continue
    4              0.000004             endif
    4              0.000082             let _selection = extend(copy(selection), {"count": selection.count-1, "startcol": selection.startcol+1})
    4   0.000117   0.000058             if s:already_selected(_selection)
                                            " This follows the previous check. When the string ends the
                                            " line, the size of the text object is just one character less
                                            continue
    4              0.000003             endif
    4              0.000024             let line = getline("'<")
    4              0.000022             let quote = strpart(object, 1)
    4              0.000047             let [before, after] = [line[:selection.startcol-3], line[selection.endcol+1:]]
    4   0.001916   0.000140             if s:odd_quotes(quote, before) || s:odd_quotes(quote, after)
                                            continue
    4              0.000003             endif
   12              0.000011         endif
                            
   12              0.000084         let candidates[size] = selection
                            
   16              0.000051     endfor
                            
    4   0.005720   0.000125     cal s:select_best_candidate(candidates)
                            

FUNCTION  20()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:164
Called 104 times
Total time:   2.411944
 Self time:   0.023102

count  total (s)   self (s)
  104              0.002059   if type(s:paste[a:reg]) == v:t_func
                                return s:paste[a:reg]()
  104              0.001039   elseif s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
  104              0.000174   end
                            
  104   2.394976   0.006134   let clipboard_data = s:try_cmd(s:paste[a:reg])
  104              0.008840   if match(&clipboard, '\v(unnamed|unnamedplus)') >= 0 && type(clipboard_data) == v:t_list && get(s:selections[a:reg].data, 0, []) ==# clipboard_data
                                " When system clipboard return is same as our cache return the cache
                                " as it contains regtype information
                                return s:selections[a:reg].data
  104              0.000194   end
  104              0.000648   return clipboard_data

FUNCTION  <SNR>116_RequestCancel()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:204
Called 87 times
Total time:   0.014314
 Self time:   0.004446

count  total (s)   self (s)
   87   0.002834   0.001807   let agent = self.Agent()
   87              0.000371   if !empty(agent)
   87   0.010027   0.001186     call agent.Cancel(self)
                              elseif get(self, 'status', '') ==# 'running'
                                let self.status = 'canceled'
   87              0.000072   endif
   87              0.000206   return self

FUNCTION  wilder#main#start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:79
Called 23 times
Total time:   0.003095
 Self time:   0.001801

count  total (s)   self (s)
                              " Workaround for https://github.com/neovim/neovim/issues/15403
   23   0.002043   0.000750   if wilder#main#in_mode() && s:enabled
                                " use timer_start so statusline does not flicker
                                " when using mappings which performs a command
   21              0.000671     call timer_start(0, {-> s:start()})
   23              0.000085   endif

FUNCTION  <SNR>23_StatusNotification()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:41
Called 39 times
Total time:   0.001075
 Self time:   0.001075

count  total (s)   self (s)
   39              0.000460   let status = get(a:params, 'status', '')
   39              0.000156   if status ==? 'error'
                                let s:agent_error = a:params.message
   39              0.000050   else
   39              0.000142     unlet! s:agent_error
   39              0.000040   endif

FUNCTION  <SNR>132_RestoreOptions()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:34
Called 1 time
Total time:   0.000176
 Self time:   0.000090

count  total (s)   self (s)
                              " In s:CleanUp(), :execute "set" restore_options .
    1              0.000004   let restore_options = ""
    1              0.000017   if get(b:, 'match_ignorecase', &ic) != &ic
    1              0.000012     let restore_options ..= (&ic ? " " : " no") .. "ignorecase"
    1   0.000048   0.000011     let &ignorecase = b:match_ignorecase
    1              0.000002   endif
    1              0.000005   if &ve != ''
    1              0.000006     let restore_options = " ve=" .. &ve .. restore_options
    1   0.000069   0.000019     set ve=
    1              0.000003   endif
    1              0.000006   return restore_options

FUNCTION  matchit#Match_wrapper()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:48
Called 1 time
Total time:   0.009200
 Self time:   0.002499

count  total (s)   self (s)
    1   0.000195   0.000020   let restore_options = s:RestoreOptions()
                              " In s:CleanUp(), we may need to check whether the cursor moved forward.
    1              0.000015   let startpos = [line("."), col(".")]
                              " if a count has been applied, use the default [count]% mode (see :h N%)
    1              0.000004   if v:count
                                exe "normal! " .. v:count .. "%"
                                return s:CleanUp(restore_options, a:mode, startpos)
    1              0.000002   end
    1              0.000022   if a:mode =~# "v" && mode(1) =~# 'ni'
                                exe "norm! gv"
    1              0.000008   elseif a:mode == "o" && mode(1) !~# '[vV]'
                                exe "norm! v"
                              " If this function was called from Visual mode, make sure that the cursor
                              " is at the correct end of the Visual range:
    1              0.000005   elseif a:mode == "v"
    1   0.001269   0.000670     execute "normal! gv\<Esc>"
    1              0.000109     let startpos = [line("."), col(".")]
    1              0.000007   endif
                            
                              " First step:  if not already done, set the script variables
                              "   s:do_BR   flag for whether there are backrefs
                              "   s:pat     parsed version of b:match_words
                              "   s:all     regexp based on s:pat and the default groups
    1              0.000026   if !exists("b:match_words") || b:match_words == ""
                                let match_words = ""
    1              0.000048   elseif b:match_words =~ ":"
    1              0.000012     let match_words = b:match_words
                              else
                                " Allow b:match_words = "GetVimMatchWords()" .
                                execute "let match_words =" b:match_words
    1              0.000003   endif
                            " Thanks to Preben "Peppe" Guldberg and Bram Moolenaar for this suggestion!
    1              0.000020   if (match_words != s:last_words) || (&mps != s:last_mps) || exists("b:match_debug")
    1              0.000045     let s:last_mps = &mps
                                " quote the special chars in 'matchpairs', replace [,:] with \| and then
                                " append the builtin pairs (/*, */, #if, #ifdef, #ifndef, #else, #elif,
                                " #endif)
    1              0.000051     let default = escape(&mps, '[$^.*~\\/?]') .. (strlen(&mps) ? "," : "") .. '\/\*:\*\/,#\s*if\%(n\=def\)\=:#\s*else\>:#\s*elif\>:#\s*endif\>'
                                " s:all = pattern with all the keywords
    1              0.000017     let match_words = match_words .. (strlen(match_words) ? "," : "") .. default
    1              0.000009     let s:last_words = match_words
    1              0.000099     if match_words !~ s:notslash .. '\\\d'
                                  let s:do_BR = 0
                                  let s:pat = match_words
    1              0.000002     else
    1              0.000010       let s:do_BR = 1
    1   0.004479   0.000046       let s:pat = s:ParseWords(match_words)
    1              0.000001     endif
    1              0.000094     let s:all = substitute(s:pat, s:notslash .. '\zs[,:]\+', '\\|', 'g')
                                " Just in case there are too many '\(...)' groups inside the pattern, make
                                " sure to use \%(...) groups, so that error E872 can be avoided
    1              0.000008     let s:all = substitute(s:all, '\\(', '\\%(', 'g')
    1              0.000002     let s:all = '\%(' .. s:all .. '\)'
    1              0.000004     if exists("b:match_debug")
                                  let b:match_pat = s:pat
    1              0.000001     endif
                                " Reconstruct the version with unresolved backrefs.
    1              0.000079     let s:patBR = substitute(match_words .. ',', s:notslash .. '\zs[,:]*,[,:]*', ',', 'g')
    1              0.000053     let s:patBR = substitute(s:patBR, s:notslash .. '\zs:\{2,}', ':', 'g')
    1              0.000001   endif
                            
                              " Second step:  set the following local variables:
                              "     matchline = line on which the cursor started
                              "     curcol    = number of characters before match
                              "     prefix    = regexp for start of line to start of match
                              "     suffix    = regexp for end of match to end of line
                              " Require match to end on or after the cursor and prefer it to
                              " start on or before the cursor.
    1              0.000008   let matchline = getline(startpos[0])
    1              0.000002   if a:word != ''
                                " word given
                                if a:word !~ s:all
                                  echohl WarningMsg|echo 'Missing rule for word:"'.a:word.'"'|echohl NONE
                                  return s:CleanUp(restore_options, a:mode, startpos)
                                endif
                                let matchline = a:word
                                let curcol = 0
                                let prefix = '^\%('
                                let suffix = '\)$'
                              " Now the case when "word" is not given
    1              0.000001   else  " Find the match that ends on or after the cursor and set curcol.
    1   0.000252   0.000027     let regexp = s:Wholematch(matchline, s:all, startpos[1]-1)
    1              0.000064     let curcol = match(matchline, regexp)
                                " If there is no match, give up.
    1              0.000003     if curcol == -1
                                  " Make sure macros abort properly
                                  "exe "norm! \<esc>"
                                  call feedkeys("\e", 'tni')
                                  return s:CleanUp(restore_options, a:mode, startpos)
    1              0.000001     endif
    1              0.000053     let endcol = matchend(matchline, regexp)
    1              0.000005     let suf = strlen(matchline) - endcol
    1              0.000004     let prefix = (curcol ? '^.*\%' .. (curcol + 1) .. 'c\%(' : '^\%(')
    1              0.000005     let suffix = (suf ? '\)\%' .. (endcol + 1) .. 'c.*$'  : '\)$')
    1              0.000001   endif
    1              0.000005   if exists("b:match_debug")
                                let b:match_match = matchstr(matchline, regexp)
                                let b:match_col = curcol+1
    1              0.000001   endif
                            
                              " Third step:  Find the group and single word that match, and the original
                              " (backref) versions of these.  Then, resolve the backrefs.
                              " Set the following local variable:
                              " group = colon-separated list of patterns, one of which matches
                              "       = ini:mid:fin or ini:fin
                              "
                              " Now, set group and groupBR to the matching group: 'if:endif' or
                              " 'while:endwhile' or whatever.  A bit of a kluge:  s:Choose() returns
                              " group . "," . groupBR, and we pick it apart.
    1   0.000429   0.000019   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, s:patBR)
    1              0.000010   let i = matchend(group, s:notslash .. ",")
    1              0.000004   let groupBR = strpart(group, i)
    1              0.000003   let group = strpart(group, 0, i-1)
                              " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
    1              0.000002   if s:do_BR " Do the hard part:  resolve those backrefs!
    1   0.000618   0.000032     let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
    1              0.000001   endif
    1              0.000003   if exists("b:match_debug")
                                let b:match_wholeBR = groupBR
                                let i = matchend(groupBR, s:notslash .. ":")
                                let b:match_iniBR = strpart(groupBR, 0, i-1)
    1              0.000001   endif
                            
                              " Fourth step:  Set the arguments for searchpair().
    1              0.000015   let i = matchend(group, s:notslash .. ":")
    1              0.000021   let j = matchend(group, '.*' .. s:notslash .. ":")
    1              0.000004   let ini = strpart(group, 0, i-1)
    1              0.000011   let mid = substitute(strpart(group, i,j-i-1), s:notslash .. '\zs:', '\\|', 'g')
    1              0.000003   let fin = strpart(group, j)
                              "Un-escape the remaining , and : characters.
    1              0.000012   let ini = substitute(ini, s:notslash .. '\zs\\\(:\|,\)', '\1', 'g')
    1              0.000006   let mid = substitute(mid, s:notslash .. '\zs\\\(:\|,\)', '\1', 'g')
    1              0.000007   let fin = substitute(fin, s:notslash .. '\zs\\\(:\|,\)', '\1', 'g')
                              " searchpair() requires that these patterns avoid \(\) groups.
    1              0.000007   let ini = substitute(ini, s:notslash .. '\zs\\(', '\\%(', 'g')
    1              0.000005   let mid = substitute(mid, s:notslash .. '\zs\\(', '\\%(', 'g')
    1              0.000007   let fin = substitute(fin, s:notslash .. '\zs\\(', '\\%(', 'g')
                              " Set mid.  This is optimized for readability, not micro-efficiency!
    1              0.000017   if a:forward && matchline =~ prefix .. fin .. suffix || !a:forward && matchline =~ prefix .. ini .. suffix
                                let mid = ""
    1              0.000001   endif
                              " Set flag.  This is optimized for readability, not micro-efficiency!
    1              0.000011   if a:forward && matchline =~ prefix .. fin .. suffix || !a:forward && matchline !~ prefix .. ini .. suffix
                                let flag = "bW"
    1              0.000001   else
    1              0.000002     let flag = "W"
    1              0.000001   endif
                              " Set skip.
    1              0.000003   if exists("b:match_skip")
                                let skip = b:match_skip
    1              0.000003   elseif exists("b:match_comment") " backwards compatibility and testing!
                                let skip = "r:" .. b:match_comment
    1              0.000001   else
    1              0.000001     let skip = 's:comment\|string'
    1              0.000000   endif
    1   0.000045   0.000018   let skip = s:ParseSkip(skip)
    1              0.000002   if exists("b:match_debug")
                                let b:match_ini = ini
                                let b:match_tail = (strlen(mid) ? mid .. '\|' : '') .. fin
    1              0.000001   endif
                            
                              " Fifth step:  actually start moving the cursor and call searchpair().
                              " Later, :execute restore_cursor to get to the original screen.
    1              0.000007   let view = winsaveview()
    1              0.000007   call cursor(0, curcol + 1)
    1              0.000014   if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
                                let skip = "0"
    1              0.000001   else
    1              0.000026     execute "if " .. skip .. "| let skip = '0' | endif"
    1              0.000001   endif
    1              0.000036   let sp_return = searchpair(ini, mid, fin, flag, skip)
    1              0.000007   if &selection isnot# 'inclusive' && a:mode == 'v'
                                " move cursor one pos to the right, because selection is not inclusive
                                " add virtualedit=onemore, to make it work even when the match ends the
                                " line
                                if !(col('.') < col('$')-1)
                                  let eolmark=1 " flag to set a mark on eol (since we cannot move there)
                                endif
                                norm! l
    1              0.000001   endif
    1              0.000005   let final_position = "call cursor(" .. line(".") .. "," .. col(".") .. ")"
                              " Restore cursor position and original screen.
    1              0.000010   call winrestview(view)
    1              0.000242   normal! m'
    1              0.000003   if sp_return > 0
    1              0.000008     execute final_position
    1              0.000001   endif
    1              0.000003   if exists('eolmark') && eolmark
                                call setpos("''", [0, line('.'), col('$'), 0]) " set mark on the eol
    1              0.000001   endif
    1   0.000266   0.000019   return s:CleanUp(restore_options, a:mode, startpos, mid .. '\|' .. fin)

FUNCTION  copilot#Suggest()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:416
Called 87 times
Total time:   0.183446
 Self time:   0.006557

count  total (s)   self (s)
   87              0.000509   try
   87   0.180580   0.003691     call copilot#Complete(function('s:HandleTriggerResult'), function('s:HandleTriggerResult'))
                              catch
                                call copilot#logger#Exception()
   87              0.000203   endtry
   87              0.000235   return ''

FUNCTION  UltiSnips#CursorMoved()
    Defined: ~/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim:157
Called 71 times
Total time:   0.696193
 Self time:   0.696184

count  total (s)   self (s)
   71   0.696041   0.696031     py3 UltiSnips_Manager._cursor_moved()

FUNCTION  <SNR>133_select_best_candidate()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:161
Called 4 times
Total time:   0.005595
 Self time:   0.000362

count  total (s)   self (s)
    4              0.000031     if len(a:candidates)
                                    " select the closest text object (the one with the smaller size)
    4              0.000066         let selection = a:candidates[min(keys(a:candidates))]
    4              0.000072         let s:history = add(s:history, {"selection": selection, "view": winsaveview()})
    4              0.000031         let s:counts[selection.object] += 1
    4   0.005302   0.000068         cal s:select(selection)
                                elseif len(s:history)
                                    " get stuck on the last selection
                                    cal s:select(get(s:history, -1).selection)
                                else
                                    " do nothing
                                    exec "sil! norm! \<ESC>"
    4              0.000005     endif

FUNCTION  <SNR>136_compensate_for_pum()
    Defined: ~/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim:10
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
                                """ The CursorMovedI event is not triggered while the popup-menu is visible,
                                """ and it's by this event that UltiSnips updates its vim-state. The fix is
                                """ to explicitly check for the presence of the popup menu, and update
                                """ the vim-state accordingly.
    2              0.000011     if pumvisible()
                                    py3 UltiSnips_Manager._cursor_moved()
    2              0.000003     endif

FUNCTION  <SNR>23_Running()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:54
Called 190 times
Total time:   0.002163
 Self time:   0.002163

count  total (s)   self (s)
  190              0.001920   return exists('s:agent.job') || exists('s:agent.client_id')

FUNCTION  copilot#agent#LspResponse()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:358
Called 92 times
Total time:   0.018123
 Self time:   0.003422

count  total (s)   self (s)
   92              0.001132   if !has_key(s:instances, a:agent_id)
                                return
   92              0.000107   endif
   92   0.016510   0.001809   call s:OnResponse(s:instances[a:agent_id], a:opts)

FUNCTION  <SNR>109_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:26
Called 23 times
Total time:   0.076107
 Self time:   0.076107

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   23              0.000158   syn clear
   23              0.000253   if exists("b:current_syntax")
                                unlet b:current_syntax
   23              0.000037   endif
                            
   23              0.000259   0verbose let s = expand("<amatch>")
   23              0.000118   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   23              0.000068   elseif s == "OFF"
                                let s = ""
   23              0.000021   endif
                            
   23              0.000050   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   46              0.000447     for name in split(s, '\.')
   23              0.000115       if !empty(name)
   23              0.038632         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
   23              0.034892         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
   23              0.000059       endif
   46              0.000092     endfor
   23              0.000030   endif

FUNCTION  wilder#main#stop()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:172
Called 22 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
   22              0.000105   let s:select_next = 0
                            
   22              0.000043   if !s:active
   22              0.000029     return
                              endif
                            
                              if exists('#WilderCmdlineChanged')
                                augroup WilderCmdlineChanged
                                  autocmd!
                                augroup END
                                augroup! WilderCmdlineChanged
                              endif
                            
                              if s:timer isnot v:null
                                call timer_stop(s:timer)
                                let s:timer = v:null
                              endif
                            
                              if exists('#WilderCmdlineLeave')
                                augroup WilderCmdlineLeave
                                  autocmd!
                                augroup END
                                augroup! WilderCmdlineLeave
                              endif
                            
                              if exists('#WilderVimResized')
                                augroup WilderVimResized
                                  autocmd!
                                augroup END
                                augroup! WilderVimResized
                              endif
                            
                              let s:active = 0
                              let s:result = {'value': [], 'data': {}}
                              let s:selected = -1
                              let s:selection_was_made = 0
                              let s:clear_previous_renderer_state = 0
                              let s:completion_stack = []
                              let s:previous_cmdline = v:null
                              let s:completion = v:null
                              let s:error = v:null
                              let s:replaced_cmdline = v:null
                              let s:completion_from_reject_completion = v:null
                            
                              if !s:hidden
                                call s:post_hook()
                              endif
                            
                              let s:hidden = 0

FUNCTION  <SNR>115_try_cmd()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:37
Called 104 times
Total time:   2.388842
 Self time:   0.027131

count  total (s)   self (s)
  104   2.379349   0.017638   let out = systemlist(a:cmd, (a:0 ? a:1 : ['']), 1)
  104              0.001788   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
  104              0.000148   endif
  104              0.000716   return out

FUNCTION  <SNR>119_RelativePath()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/doc.vim:36
Called 87 times
Total time:   0.009573
 Self time:   0.009573

count  total (s)   self (s)
   87              0.000752   if exists('b:copilot_relative_path')
                                return b:copilot_relative_path
   87              0.000442   elseif exists('b:copilot_root')
                                let root = b:copilot_root
   87              0.001037   elseif len(get(b:, 'projectionist', {}))
                                let root = sort(keys(b:projectionist), { a, b -> a < b })[0]
   87              0.000143   else
   87              0.000992     let root = getcwd()
   87              0.000160   endif
   87              0.001405   let root = tr(root, s:slash, '/') . '/'
   87              0.001644   if strpart(tr(a:absolute, 'A-Z', 'a-z'), 0, len(root)) ==# tr(root, 'A-Z', 'a-z')
   87              0.000731     return strpart(a:absolute, len(root))
                              else
                                return fnamemodify(a:absolute, ':t')
                              endif

FUNCTION  <SNR>132_Wholematch()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:379
Called 1 time
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
    1              0.000004   let group = '\%(' .. a:pat .. '\)'
    1              0.000004   let prefix = (a:start ? '\(^.*\%<' .. (a:start + 2) .. 'c\)\zs' : '^')
    1              0.000004   let len = strlen(a:string)
    1              0.000005   let suffix = (a:start+1 < len ? '\(\%>' .. (a:start+1) .. 'c.*$\)\@=' : '$')
    1              0.000194   if a:string !~ prefix .. group .. suffix
                                let prefix = ''
    1              0.000001   endif
    1              0.000006   return prefix .. group .. suffix

FUNCTION  copilot#OnInsertLeave()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:449
Called 25 times
Total time:   0.020555
 Self time:   0.000419

count  total (s)   self (s)
   25   0.020516   0.000380   return copilot#Clear()

FUNCTION  wilder#main#in_mode()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:53
Called 45 times
Total time:   0.001584
 Self time:   0.001584

count  total (s)   self (s)
   45              0.001358   return mode(1) ==# 'c' && index(s:opts.modes, getcmdtype()) >= 0

FUNCTION  copilot#Complete()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:168
Called 87 times
Total time:   0.176889
 Self time:   0.030648

count  total (s)   self (s)
   87              0.000909   if exists('g:_copilot_timer')
                                call timer_stop(remove(g:, '_copilot_timer'))
   87              0.000178   endif
   87   0.043103   0.001656   let params = copilot#doc#Params()
   87              0.000706   if !exists('b:_copilot.params') || b:_copilot.params !=# params
   87   0.102909   0.003682     let b:_copilot = {'params': params, 'first': copilot#Request('getCompletions', params)}
   87              0.002550     let g:_copilot_last = b:_copilot
   87              0.000198   endif
   87              0.000553   let completion = b:_copilot.first
   87              0.000247   if !a:0
                                return completion.Await()
   87              0.000141   else
   87   0.006320   0.003234     call copilot#agent#Result(completion, a:1)
   87              0.000313     if a:0 > 1
   87   0.016670   0.014189       call copilot#agent#Error(completion, a:2)
   87              0.000102     endif
   87              0.000079   endif

FUNCTION  <SNR>132_Choose()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:523
Called 2 times
Total time:   0.000499
 Self time:   0.000499

count  total (s)   self (s)
    2              0.000018   let tail = (a:patterns =~ a:comma .. "$" ? a:patterns : a:patterns .. a:comma)
    2              0.000027   let i = matchend(tail, s:notslash .. a:comma)
    2              0.000003   if a:0
    2              0.000013     let alttail = (a:1 =~ a:comma .. "$" ? a:1 : a:1 .. a:comma)
    2              0.000023     let j = matchend(alttail, s:notslash .. a:comma)
    2              0.000001   endif
    2              0.000007   let current = strpart(tail, 0, i-1)
    2              0.000003   if a:branch == ""
    1              0.000002     let currpat = current
    1              0.000001   else
    1              0.000022     let currpat = substitute(current, s:notslash .. a:branch, '\\|', 'g')
    2              0.000001   endif
    6              0.000118   while a:string !~ a:prefix .. currpat .. a:suffix
    4              0.000011     let tail = strpart(tail, i)
    4              0.000043     let i = matchend(tail, s:notslash .. a:comma)
    4              0.000005     if i == -1
                                  return -1
    4              0.000002     endif
    4              0.000011     let current = strpart(tail, 0, i-1)
    4              0.000005     if a:branch == ""
                                  let currpat = current
    4              0.000003     else
    4              0.000037       let currpat = substitute(current, s:notslash .. a:branch, '\\|', 'g')
    4              0.000002     endif
    4              0.000004     if a:0
    4              0.000010       let alttail = strpart(alttail, j)
    4              0.000028       let j = matchend(alttail, s:notslash .. a:comma)
    4              0.000002     endif
    6              0.000012   endwhile
    2              0.000003   if a:0
    2              0.000009     let current = current .. a:comma .. strpart(alttail, 0, j-1)
    2              0.000001   endif
    2              0.000003   return current

FUNCTION  <SNR>23_HandleTriggerResult()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:407
Called 65 times
Total time:   0.031745
 Self time:   0.002483

count  total (s)   self (s)
   65              0.000382   if !exists('b:_copilot')
                                return
   65              0.000062   endif
   65              0.000530   let b:_copilot.suggestions = get(a:result, 'completions', [])
   65              0.000219   let b:_copilot.choice = 0
   65   0.030239   0.000977   call s:UpdatePreview()

FUNCTION  <SNR>116_SetUpRequest()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:87
Called 92 times
Total time:   0.014317
 Self time:   0.014317

count  total (s)   self (s)
   92              0.005486   let request = { 'agent_id': a:agent.id, 'id': a:id, 'method': a:method, 'params': a:params, 'Agent': function('s:RequestAgent'), 'Wait': function('s:RequestWait'), 'Await': function('s:RequestAwait'), 'Cancel': function('s:RequestCancel'), 'resolve': [], 'reject': [], 'status': 'running'}
   92              0.000958   let a:agent.requests[a:id] = request
   92              0.000713   let args = a:000[2:-1]
   92              0.000521   if len(args)
                                if !empty(a:1)
                                  call add(request.resolve, { v -> call(a:1, [v] + args)})
                                endif
                                if !empty(a:2)
                                  call add(request.reject, { v -> call(a:2, [v] + args)})
                                endif
                                return request
   92              0.000121   endif
   92              0.000408   if a:0 && !empty(a:1)
                                call add(request.resolve, a:1)
   92              0.000125   endif
   92              0.000440   if a:0 > 1 && !empty(a:2)
                                call add(request.reject, a:2)
   92              0.000101   endif
   92              0.000303   return request

FUNCTION  copilot#doc#Get()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/doc.vim:54
Called 87 times
Total time:   0.033877
 Self time:   0.021873

count  total (s)   self (s)
   87              0.001722   let absolute = tr(@%, s:slash, '/')
   87              0.003875   if absolute !~# '^\a\+:\|^/\|^$' && &buftype =~# '^\%(nowrite\)\=$'
   87              0.004298     let absolute = substitute(tr(getcwd(), s:slash, '/'), '/\=$', '/', '') . absolute
   87              0.000246   endif
   87   0.014366   0.004793   let doc = { 'uri': bufnr(''), 'version': getbufvar('', 'changedtick'), 'relativePath': s:RelativePath(absolute), 'insertSpaces': &expandtab ? v:true : v:false, 'tabSize': shiftwidth(), 'indentSize': shiftwidth(), }
   87              0.000725   let line = getline('.')
   87              0.002187   let col_byte = col('.') - (mode() =~# '^[iR]' || empty(line))
   87   0.004409   0.001978   let col_utf16 = copilot#doc#UTF16Width(strpart(line, 0, col_byte))
   87              0.001121   let doc.position = {'line': line('.') - 1, 'character': col_utf16}
   87              0.000240   return doc

FUNCTION  <SNR>133_select()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:185
Called 32 times
Total time:   0.093690
 Self time:   0.070320

count  total (s)   self (s)
   32   0.032719   0.009835     exe "sil! norm! \<ESC>v\<ESC>v"
   32              0.000476     if get(s:vim_text_objects, a:selection.object)
                                    " use counts when selecting vim text objects
   32   0.059663   0.059178         exe "sil! norm! " . a:selection.count . a:selection.object
                                else
                                    " counts might not be suported by non-default text objects
                                    for n in range(a:selection.count)
                                        exe "sil! norm " . a:selection.object
                                    endfor
   32              0.000047     endif

FUNCTION  nvim_treesitter#foldexpr()
    Defined: ~/.local/share/nvim/lazy/nvim-treesitter/autoload/nvim_treesitter.vim:5
Called 28 times
Total time:   0.002291
 Self time:   0.002291

count  total (s)   self (s)
   28              0.002243 	return luaeval(printf('require"nvim-treesitter.fold".get_fold_indic(%d)', v:lnum))

FUNCTION  <SNR>133_init()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:54
Called 4 times
Total time:   0.001442
 Self time:   0.000972

count  total (s)   self (s)
    4              0.000092     let s:origin = getpos(".")
    4              0.000091     let s:history = []
    4              0.000060     let s:counts = {}
    4   0.000658   0.000188     let _objects = s:load_objects(a:objects)
   32              0.000205     for object in get(_objects, &ft, get(_objects, "*", []))
   28              0.000163         let s:counts[object] = 1
   32              0.000116     endfor

FUNCTION  <SNR>121_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:94
Called 22 times
Total time:   0.001134
 Self time:   0.000614

count  total (s)   self (s)
   22   0.000603   0.000312   if !wilder#main#in_mode() || !s:enabled
   22   0.000437   0.000207     call wilder#main#stop()
   22              0.000018     return
                              endif
                            
                              if !s:init && wilder#options#get('use_python_remote_plugin')
                                let s:init = 1
                            
                                try
                                  if !has('nvim')
                                    " set up yarp
                                    call wilder#yarp#init()
                                  endif
                            
                                  call _wilder_init({'num_workers': s:opts.num_workers})
                                catch
                                  echohl ErrorMsg
                                  echomsg 'wilder: Python initialization failed'
                                  echomsg v:exception
                                  echohl Normal
                                endtry
                              endif
                            
                              if s:opts.use_cmdlinechanged
                                if !exists('#WilderCmdlineChanged')
                                  augroup WilderCmdlineChanged
                                    autocmd!
                                    " call from a timer so statusline does not change during mappings
                                    autocmd CmdlineChanged * call timer_start(0, {_ -> s:do(1)})
                                  augroup END
                                endif
                              elseif s:timer is v:null
                                  let s:timer = timer_start(s:opts.interval, {_ -> s:do(1)}, {'repeat': -1})
                              endif
                            
                              if !exists('#WilderCmdlineLeave')
                                augroup WilderCmdlineLeave
                                  autocmd!
                                  autocmd CmdlineLeave * call wilder#main#stop()
                                  autocmd CmdwinEnter * call wilder#main#stop()
                                augroup END
                              endif
                            
                              if !exists('#WilderVimResized')
                                augroup WilderVimResized
                                  autocmd!
                                    autocmd VimResized * call timer_start(0, {_ -> s:draw_resized()})
                                augroup END
                              endif
                            
                              let s:active = 1
                              let s:hidden = 0
                            
                              if !has_key(s:opts, 'renderer')
                                let s:opts.renderer = wilder#wildmenu_renderer()
                              endif
                            
                              if !has_key(s:opts, 'pipeline')
                                let s:opts.pipeline = [ wilder#branch(   wilder#cmdline_pipeline(),   has('nvim') && has('python3')     ? wilder#python_search_pipeline()     : wilder#vim_search_pipeline(), ), ]
                              endif
                            
                              let s:session_id += 1
                            
                              call s:pre_hook()
                            
                              call s:do(0)

FUNCTION  copilot#Request()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:90
Called 92 times
Total time:   0.101483
 Self time:   0.004721

count  total (s)   self (s)
   92   0.005678   0.001278   let agent = copilot#Agent()
   92   0.095619   0.003257   return call(agent.Request, [a:method, a:params] + a:000)

FUNCTION  <SNR>23_BufferDisabled()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:142
Called 98 times
Total time:   0.007526
 Self time:   0.007526

count  total (s)   self (s)
   98              0.000601   if exists('b:copilot_disabled')
                                return empty(b:copilot_disabled) ? 0 : 3
   98              0.000110   endif
   98              0.000312   if exists('b:copilot_enabled')
                                return empty(b:copilot_enabled) ? 4 : 0
   98              0.000078   endif
   98              0.001706   let short = empty(&l:filetype) ? '.' : split(&l:filetype, '\.', 1)[0]
   98              0.000723   let config = get(g:, 'copilot_filetypes', {})
   98              0.000829   if type(config) == v:t_dict && has_key(config, &l:filetype)
                                return empty(config[&l:filetype])
   98              0.000368   elseif has_key(config, short)
                                return empty(config[short])
   98              0.000303   elseif has_key(config, '*')
                                return empty(config['*'])
   98              0.000088   else
   98              0.000545     return get(s:filetype_defaults, short, 1) == 0 ? 2 : 0
                              endif

FUNCTION  <SNR>57_current()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:210
Called 12 times
Total time:   0.001118
 Self time:   0.001118

count  total (s)   self (s)
   12              0.000495   let fn = expand('%:p', 1)
   12              0.000278   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
   12              0.000101   if empty(fn) | return getcwd() | endif  " opening vim without a file
   12              0.000091   if g:rooter_resolve_links | let fn = resolve(fn) | endif
   12              0.000104   return fnamemodify(fn, ':h')

FUNCTION  <SNR>132_Ref()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:399
Called 1 time
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
    1              0.000013   let len = strlen(a:string)
    1              0.000004   if a:d == 0
                                let start = 0
    1              0.000001   else
    1              0.000002     let cnt = a:d
    1              0.000002     let match = a:string
    2              0.000004     while cnt
    1              0.000002       let cnt = cnt - 1
    1              0.000026       let index = matchend(match, s:notslash .. '\\(')
    1              0.000005       if index == -1
                                    return ""
    1              0.000001       endif
    1              0.000009       let match = strpart(match, index)
    2              0.000005     endwhile
    1              0.000006     let start = len - strlen(match)
    1              0.000004     if a:0 == 1 && a:1 == "start"
                                  return start - 2
    1              0.000001     endif
    1              0.000002     let cnt = 1
    2              0.000004     while cnt
    1              0.000040       let index = matchend(match, s:notslash .. '\\(\|\\)') - 1
    1              0.000004       if index == -2
                                    return ""
    1              0.000001       endif
                                  " Increment if an open, decrement if a ')':
    1              0.000009       let cnt = cnt + (match[index]=="(" ? 1 : -1)  " ')'
    1              0.000006       let match = strpart(match, index+1)
    2              0.000003     endwhile
    1              0.000003     let start = start - 2
    1              0.000005     let len = len - start - strlen(match)
    1              0.000001   endif
    1              0.000002   if a:0 == 1
                                return len
    1              0.000003   elseif a:0 == 2
                                return "let " .. a:1 .. "=" .. start .. "| let " .. a:2 .. "=" .. len
    1              0.000001   else
    1              0.000007     return strpart(a:string, start, len)
                              endif

FUNCTION  <SNR>116_LspRequest()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:365
Called 92 times
Total time:   0.092362
 Self time:   0.078044

count  total (s)   self (s)
   92              0.071775   let id = v:lua.require'_copilot'.lsp_request(self.id, a:method, a:params)
   92              0.001129   if id isnot# v:null
   92   0.019145   0.004827     return call('s:SetUpRequest', [self, id, a:method, a:params] + a:000)
                              endif
                              if has_key(self, 'client_id')
                                call copilot#agent#LspExit(self.client_id, -1, -1)
                              endif
                              throw 'copilot#agent: LSP client not available'

FUNCTION  <SNR>22_Event()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/plugin/copilot.vim:45
Called 123 times
Total time:   0.126398
 Self time:   0.004620

count  total (s)   self (s)
  123              0.000559   try
  123   0.124650   0.002872     call call('copilot#On' . a:type, [])
                              catch
                                call copilot#logger#Exception()
  123              0.000184   endtry

FUNCTION  Fcitx2en()
    Defined: ~/.local/share/nvim/lazy/fcitx.vim/plugin/fcitx.vim:45
Called 25 times
Total time:   0.039336
 Self time:   0.039336

count  total (s)   self (s)
   25              0.039249         py3 fcitx2en()

FUNCTION  <SNR>116_Callback()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:548
Called 65 times
Total time:   0.034010
 Self time:   0.002265

count  total (s)   self (s)
   65              0.000754   call remove(a:request.waiting, a:timer)
   65              0.000324   if has_key(a:request, a:type)
   65   0.032729   0.000983     call a:callback(a:request[a:type])
   65              0.000073   endif

FUNCTION  <SNR>87_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:197
Called 1107 times
Total time:   0.030833
 Self time:   0.030833

count  total (s)   self (s)
 1107              0.013964   if exists('w:paren_hl_on') && w:paren_hl_on
   29              0.000204     silent! call matchdelete(3)
   29              0.000142     let w:paren_hl_on = 0
 1107              0.001968   endif

FUNCTION  copilot#Agent()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:77
Called 190 times
Total time:   0.007618
 Self time:   0.002841

count  total (s)   self (s)
  190   0.006990   0.002213   call s:Start()
  190              0.000402   return s:agent

FUNCTION  <SNR>116_AgentCancel()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:194
Called 87 times
Total time:   0.008840
 Self time:   0.003687

count  total (s)   self (s)
   87              0.000884   if has_key(self.requests, get(a:request, 'id', ''))
   22              0.000183     call remove(self.requests, a:request.id)
   22   0.005780   0.000627     call self.Notify('$/cancelRequest', {'id': a:request.id})
   87              0.000183   endif
   87              0.000621   if get(a:request, 'status', '') ==# 'running'
   22              0.000143     let a:request.status = 'canceled'
   87              0.000078   endif

FUNCTION  copilot#OnInsertEnter()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:453
Called 25 times
Total time:   0.037544
 Self time:   0.015716

count  total (s)   self (s)
   25   0.002038   0.000859   let s:is_mapped = copilot#IsMapped()
   25              0.013478   let s:dest = bufnr('^copilot://$')
   25              0.000376   if s:dest > 0 && bufwinnr(s:dest) < 0
                                let s:dest = -1
   25              0.000048   endif
   25              0.000101   if s:dest < 0 && !s:has_ghost_text
                                let s:dest = 0
   25              0.000024   endif
   25   0.021207   0.000558   return copilot#Schedule()

FUNCTION  copilot#logger#Raw()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/logger.vim:18
Called 116 times
Total time:   0.007383
 Self time:   0.007207

count  total (s)   self (s)
  116              0.003012   if $COPILOT_AGENT_VERBOSE !~# '^\%(1\|true\)$' && a:level < 1
   86              0.000251     return
   30              0.000030   endif
   30              0.000469   let lines = type(a:message) == v:t_list ? copy(a:message) : split(a:message, "\n", 1)
   30              0.000062   try
   30              0.000797     if !filewritable(s:log_file)
                                  return
   30              0.000025     endif
   30   0.001009   0.000834     call map(lines, { k, L -> type(L) == v:t_func ? call(L, []) : L })
   30              0.001104     call writefile(lines, s:log_file, 'a')
                              catch
   30              0.000048   endtry

FUNCTION  <SNR>116_OnResponse()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:235
Called 247 times
Total time:   0.042974
 Self time:   0.035591

count  total (s)   self (s)
  247              0.001684   let response = a:response
  247              0.001947   let id = get(response, 'id', v:null)
  247              0.001099   if has_key(response, 'method')
  155              0.001032     let params = get(response, 'params', v:null)
  155              0.000777     if empty(id)
  155              0.001017       if has_key(a:agent.notifications, response.method)
   39              0.000704         call timer_start(0, { _ -> a:agent.notifications[response.method](params) })
  116              0.000603       elseif response.method ==# 'LogMessage'
  116   0.012126   0.004743         call copilot#logger#Raw(get(params, 'level', 3), get(params, 'message', ''))
  155              0.000212       endif
                                elseif has_key(a:agent.methods, response.method)
                                  call timer_start(0, function('s:DispatchMessage', [a:agent, a:agent.methods[response.method], id, params]))
                                else
                                  return s:Send(a:agent, {"id": id, "error": {"code": -32700, "message": "Method not found: " . response.method}})
  155              0.000164     endif
  155              0.000193     return
   92              0.000083   endif
   92              0.000503   if !has_key(a:agent.requests, id)
   22              0.000030     return
   70              0.000055   endif
   70              0.000534   let request = remove(a:agent.requests, id)
   70              0.000746   if request.status ==# 'canceled'
                                return
   70              0.000054   endif
   70              0.000402   let request.waiting = {}
   70              0.000385   let resolve = remove(request, 'resolve')
   70              0.000309   let reject = remove(request, 'reject')
   70              0.000249   if has_key(response, 'result')
   70              0.000264     let request.status = 'success'
   70              0.000226     let request.result = response.result
  135              0.000680     for Cb in resolve
   65              0.001711       let request.waiting[timer_start(0, function('s:Callback', [request, 'result', Cb]))] = 1
  135              0.000266     endfor
                              else
                                let request.status = 'error'
                                let request.error = response.error
                                for Cb in reject
                                  let request.waiting[timer_start(0, function('s:Callback', [request, 'error', Cb]))] = 1
                                endfor
   70              0.000061   endif

FUNCTION  remote#host#PluginsForHost()
    Defined: /usr/share/nvim/runtime/autoload/remote/host.vim:177
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000021   if !has_key(s:plugins_for_host, a:host)
                                let s:plugins_for_host[a:host] = []
    2              0.000004   end
    2              0.000013   return s:plugins_for_host[a:host]

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim:176
Called 137 times
Total time:   0.358847
 Self time:   0.358847

count  total (s)   self (s)
  137              0.358478     py3 UltiSnips_Manager._track_change()

FUNCTION  provider#Poll()
    Defined: /usr/share/nvim/runtime/autoload/provider.vim:6
Called 2 times
Total time:   0.824475
 Self time:   0.824475

count  total (s)   self (s)
    2              0.000041   let job = {'rpc': v:true, 'stderr_buffered': v:true}
    2              0.000007   if a:0
    2              0.000038     let job = extend(job, a:1)
    2              0.000008   endif
    2              0.000003   try
    2              0.018798     let channel_id = jobstart(a:argv, job)
    2              0.805457     if channel_id > 0 && rpcrequest(channel_id, 'poll') ==# 'ok'
    2              0.000025       return channel_id
                                endif
                              catch
                                echomsg v:throwpoint
                                echomsg v:exception
                                for row in get(job, 'stderr', [])
                                  echomsg row
                                endfor
    2              0.000011   endtry
                              throw remote#host#LoadErrorForHost(a:orig_name, a:log_env)

FUNCTION  UltiSnips#Anon()
    Defined: ~/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim:148
Called 1 time
Total time:   0.027930
 Self time:   0.026989

count  total (s)   self (s)
                                " Takes the same arguments as SnippetManager.expand_anon:
                                " (value, trigger="", description="", options="")
    1              0.001828     py3 args = vim.eval("a:000")
    1              0.001368     py3 value = vim.eval("a:value")
    1   0.024714   0.023773     py3 UltiSnips_Manager.expand_anon(value, *args)
    1              0.000007     return ""

FUNCTION  UltiSnips#JumpForwards()
    Defined: ~/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim:131
Called 2 times
Total time:   0.047989
 Self time:   0.046484

count  total (s)   self (s)
    2   0.000061   0.000035     call s:compensate_for_pum()
    2   0.047909   0.046430     py3 UltiSnips_Manager.jump_forwards()
    2              0.000014     return ""

FUNCTION  <SNR>132_ParseWords()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:343
Called 1 time
Total time:   0.004434
 Self time:   0.001833

count  total (s)   self (s)
    1              0.000138   let groups = substitute(a:groups .. ",", s:notslash .. '\zs[,:]*,[,:]*', ',', 'g')
    1              0.000110   let groups = substitute(groups, s:notslash .. '\zs:\{2,}', ':', 'g')
    1              0.000007   let parsed = ""
    9              0.000104   while groups =~ '[^,:]'
    8              0.000170     let i = matchend(groups, s:notslash .. ':')
    8              0.000158     let j = matchend(groups, s:notslash .. ',')
    8              0.000072     let ini = strpart(groups, 0, i-1)
    8              0.000045     let tail = strpart(groups, i, j-i-1) .. ":"
    8              0.000028     let groups = strpart(groups, j)
    8              0.000025     let parsed = parsed .. ini
    8              0.000116     let i = matchend(tail, s:notslash .. ':')
   19              0.000051     while i != -1
                                  " In 'if:else:endif', ini='if' and word='else' and then word='endif'.
   11              0.000053       let word = strpart(tail, 0, i-1)
   11              0.000037       let tail = strpart(tail, i)
   11              0.000141       let i = matchend(tail, s:notslash .. ':')
   11   0.002901   0.000300       let parsed = parsed .. ":" .. s:Resolve(ini, word, "word")
   19              0.000037     endwhile " Now, tail has been used up.
    8              0.000034     let parsed = parsed .. ","
    9              0.000011   endwhile " groups =~ '[^,:]'
    1              0.000008   let parsed = substitute(parsed, ',$', '', '')
    1              0.000002   return parsed

FUNCTION  provider#python3#Prog()
    Defined: /usr/share/nvim/runtime/autoload/provider/python3.vim:13
Called 2 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    2              0.000017   return s:prog

FUNCTION  <SNR>57_match()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:147
Called 72 times
Total time:   0.005740
 Self time:   0.003091

count  total (s)   self (s)
   72              0.000403   if a:pattern[0] == '='
                                return s:is(a:dir, a:pattern[1:])
   72              0.000236   elseif a:pattern[0] == '^'
                                return s:sub(a:dir, a:pattern[1:])
   72              0.000202   elseif a:pattern[0] == '>'
                                return s:child(a:dir, a:pattern[1:])
   72              0.000084   else
   72   0.003688   0.001039     return s:has(a:dir, a:pattern)
                              endif

FUNCTION  remote#define#request()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim:194
Called 1 time
Total time:   0.000544
 Self time:   0.000544

count  total (s)   self (s)
    1              0.000009   let s:busy[a:chan] = get(s:busy, a:chan, 0)+1
    1              0.000490   let val = call('rpcrequest', [a:chan]+a:000)
    1              0.000009   let s:busy[a:chan] -= 1
    1              0.000012   if s:busy[a:chan] == 0
    1              0.000010     for msg in get(s:pending_notifications, a:chan, [])
                                  call call('rpcnotify', [a:chan] + msg)
    1              0.000002     endfor
    1              0.000003     let s:pending_notifications[a:chan] = []
    1              0.000001   endif
    1              0.000002   return val

FUNCTION  <SNR>116_RequestAgent()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:79
Called 87 times
Total time:   0.001027
 Self time:   0.001027

count  total (s)   self (s)
   87              0.000888   return get(s:instances, self.agent_id, v:null)

FUNCTION  <SNR>92_GetRpcFunction()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim:175
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002   if a:sync ==# 'urgent'
                                return 'rpcnotify'
    1              0.000001   elseif a:sync
    1              0.000001     return 'remote#define#request'
                              endif
                              return 'remote#define#notify'

FUNCTION  copilot#Clear()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:109
Called 123 times
Total time:   0.080406
 Self time:   0.010695

count  total (s)   self (s)
  123              0.001029   if exists('g:_copilot_timer')
   11              0.000131     call timer_stop(remove(g:, '_copilot_timer'))
  123              0.000186   endif
  123              0.000479   if exists('s:uuid')
    2   0.000940   0.000031     call copilot#Request('notifyRejected', {'uuids': [remove(s:, 'uuid')]})
  123              0.000122   endif
  123              0.000537   if exists('b:_copilot')
   87   0.018224   0.001529     call copilot#agent#Cancel(get(b:_copilot, 'first', {}))
   87   0.002848   0.001551     call copilot#agent#Cancel(get(b:_copilot, 'cycling', {}))
  123              0.000107   endif
  123   0.052562   0.001751   call s:UpdatePreview()
  123              0.000507   unlet! b:_copilot
  123              0.000242   return ''

FUNCTION  wildfire#Start()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:32
Called 4 times
Total time:   0.113273
 Self time:   0.000291

count  total (s)   self (s)
    4   0.001603   0.000161     cal s:init(a:objects)
    4   0.111658   0.000118     cal wildfire#Fuel(a:repeat)

FUNCTION  <SNR>57_has()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:174
Called 72 times
Total time:   0.002649
 Self time:   0.002649

count  total (s)   self (s)
                              " We do not want a:dir to be treated as a glob so escape any wildcards.
                              " If this approach is problematic (e.g. on Windows), an alternative
                              " might be to change directory to a:dir, call globpath() with just
                              " a:identifier, then restore the working directory.
   72              0.002345   return !empty(globpath(escape(a:dir, '?*[]'), a:identifier, 1))

FUNCTION  <SNR>57_cd()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:226
Called 12 times
Total time:   0.000164
 Self time:   0.000164

count  total (s)   self (s)
   12              0.000145   if a:dir == getcwd() | return | endif
                              execute g:rooter_cd_cmd fnameescape(a:dir)
                              if !g:rooter_silent_chdir | redraw | echo 'cwd: '.a:dir | endif
                              if exists('#User#RooterChDir')
                                execute 'doautocmd' s:nomodeline 'User RooterChDir'
                              endif

FUNCTION  <SNR>23_UpdatePreview()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:353
Called 188 times
Total time:   0.080073
 Self time:   0.036998

count  total (s)   self (s)
  188              0.000447   try
  188   0.037301   0.004174     let [text, outdent, delete, uuid] = s:SuggestionTextWithAdjustments()
  188              0.002501     let text = split(text, "\n", 1)
  188              0.001114     if empty(text[-1])
  185              0.001057       call remove(text, -1)
  188              0.000190     endif
  188              0.000482     if s:dest > 0
                                  call s:WindowPreview(text, outdent, delete)
  188              0.000289     endif
  188              0.000676     if empty(text) || s:dest >= 0
  185   0.011117   0.002724       return s:ClearPreview()
    3              0.000002     endif
    3              0.000013     if exists('b:_copilot.cycling_callbacks')
                                  let annot = '(1/)'
    3              0.000010     elseif exists('b:_copilot.cycling')
                                  let annot = '(' . (b:_copilot.choice + 1) . '/' . len(b:_copilot.suggestions) . ')'
    3              0.000003     else
    3              0.000006       let annot = ''
    3              0.000002     endif
    3   0.000180   0.000035     call s:ClearPreview()
    3              0.000007     if s:has_nvim_ghost_text
    3              0.000014       let data = {'id': 1}
    3              0.000029       let data.virt_text_win_col = virtcol('.') - 1
    3              0.000025       let append = strpart(getline('.'), col('.') - 1 + delete)
    3              0.000042       let data.virt_text = [[text[0] . append . repeat(' ', delete - len(text[0])), s:hlgroup]]
    3              0.000010       if len(text) > 1
    3   0.000194   0.000150         let data.virt_lines = map(text[1:-1], { _, l -> [[l, s:hlgroup]] })
    3              0.000012         if !empty(annot)
                                      let data.virt_lines[-1] += [[' '], [annot, s:annot_hlgroup]]
    3              0.000003         endif
                                  elseif len(annot)
                                    let data.virt_text += [[' '], [annot, s:annot_hlgroup]]
    3              0.000002       endif
    3              0.000008       let data.hl_mode = 'combine'
    3   0.000154   0.000135       call nvim_buf_set_extmark(0, copilot#NvimNs(), line('.')-1, col('.')-1, data)
                                else
                                  call prop_add(line('.'), col('.'), {'type': s:hlgroup, 'text': text[0]})
                                  for line in text[1:]
                                    call prop_add(line('.'), 0, {'type': s:hlgroup, 'text_align': 'below', 'text': line})
                                  endfor
                                  if !empty(annot)
                                    call prop_add(line('.'), col('$'), {'type': s:annot_hlgroup, 'text': ' ' . annot})
                                  endif
    3              0.000002     endif
    3              0.000016     if uuid !=# get(s:, 'uuid', '')
    3              0.000010       let s:uuid = uuid
    3   0.001389   0.000041       call copilot#Request('notifyShown', {'uuid': uuid})
    3              0.000004     endif
                              catch
                                return copilot#logger#Exception()
  188              0.000312   endtry

FUNCTION  copilot#Enabled()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:162
Called 98 times
Total time:   0.017375
 Self time:   0.004464

count  total (s)   self (s)
   98   0.017250   0.004339   return get(g:, 'copilot_enabled', 1) && empty(s:BufferDisabled()) && empty(copilot#Agent().StartupError())

FUNCTION  copilot#NvimNs()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:105
Called 191 times
Total time:   0.002161
 Self time:   0.002161

count  total (s)   self (s)
  191              0.001948   return nvim_create_namespace('github-copilot')

FUNCTION  copilot#Schedule()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:440
Called 98 times
Total time:   0.083370
 Self time:   0.005725

count  total (s)   self (s)
   98   0.061376   0.001106   call copilot#Clear()
   98   0.018903   0.001528   if !s:is_mapped || !s:dest || !copilot#Enabled()
                                return
   98              0.000076   endif
   98              0.000715   let delay = a:0 ? a:1 : get(g:, 'copilot_idle_delay', 75)
   98              0.001918   let g:_copilot_timer = timer_start(delay, function('s:Trigger', [bufnr('')]))

FUNCTION  remote#define#AutocmdBootstrap()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim:107
Called 1 time
Total time:   0.571400
 Self time:   0.000159

count  total (s)   self (s)
    1   0.570572   0.000028   let channel = remote#host#Require(a:host)
                            
    1              0.000049   exe 'autocmd! '.a:opts.group
    1              0.000002   if channel
    1   0.000168   0.000037     call remote#define#AutocmdOnChannel(channel, a:method, a:sync, a:name, a:opts)
    1   0.000600   0.000032     exe eval(a:forward)
                              else
                                exe 'augroup! '.a:opts.group
                                echoerr 'Host "'a:host.'" for "'.a:name.'" autocmd is not available'
    1              0.000001   endif

FUNCTION  UltiSnips#LeavingInsertMode()
    Defined: ~/.local/share/nvim/lazy/ultisnips/autoload/UltiSnips.vim:172
Called 10 times
Total time:   0.009156
 Self time:   0.009156

count  total (s)   self (s)
   10              0.009130     py3 UltiSnips_Manager._leaving_insert_mode()

FUNCTION  remote#define#AutocmdOnChannel()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim:122
Called 1 time
Total time:   0.000130
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000006   let rpcargs = [a:channel, '"'.a:method.'"']
    1   0.000033   0.000016   call s:AddEval(rpcargs, a:opts)
                            
    1   0.000075   0.000028   let autocmd_def = s:GetAutocmdPrefix(a:name, a:opts) . ' call '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'
    1              0.000015   exe autocmd_def

FUNCTION  <SNR>23_Start()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:58
Called 190 times
Total time:   0.004777
 Self time:   0.002614

count  total (s)   self (s)
  190   0.004227   0.002064   if s:Running()
  190              0.000296     return
                              endif
                              let s:agent = copilot#agent#New({'notifications': { 'statusNotification': function('s:StatusNotification'), 'PanelSolution': function('copilot#panel#Solution'), 'PanelSolutionsDone': function('copilot#panel#SolutionsDone'), }, 'editorConfiguration' : s:EditorConfiguration()})

FUNCTION  <SNR>116_LspNotify()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:383
Called 22 times
Total time:   0.005153
 Self time:   0.005153

count  total (s)   self (s)
   22              0.005088   return v:lua.require'_copilot'.rpc_notify(self.id, a:method, a:params)

FUNCTION  <SNR>116_AgentStartupError()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:490
Called 98 times
Total time:   0.002168
 Self time:   0.002168

count  total (s)   self (s)
   98              0.000848   while has_key(self, 'job') && !has_key(self, 'startup_error') && !has_key(self, 'capabilities')
                                sleep 10m
   98              0.000182   endwhile
   98              0.000523   if has_key(self, 'capabilities') || has_key(self, 'client_id')
   98              0.000138     return ''
                              else
                                return get(self, 'startup_error', 'Something unexpected went wrong spawning the agent')
                              endif

FUNCTION  <SNR>133_size()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:209
Called 12 times
Total time:   0.000251
 Self time:   0.000251

count  total (s)   self (s)
   12              0.000070     if a:selection.startline == a:selection.endline
    8              0.000050         return a:selection.endcol - a:selection.startcol + 1
    4              0.000004     endif
    4              0.000041     let size = len(getline(a:selection.startline)) - a:selection.startcol + a:selection.endcol + 1
    4              0.000031     let size += winwidth(0) * (a:selection.endline - a:selection.startline - 1)
    4              0.000008     return size

FUNCTION  <SNR>92_GetAutocmdPrefix()
    Defined: /usr/share/nvim/runtime/autoload/remote/define.vim:228
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000003   if has_key(a:opts, 'group')
    1              0.000002     let group = a:opts.group
                              else
                                let group = s:GetNextAutocmdGroup()
    1              0.000001   endif
    1              0.000003   let rv = ['autocmd!', group, a:name]
                            
    1              0.000002   if has_key(a:opts, 'pattern')
    1              0.000005     call add(rv, a:opts.pattern)
                              else
                                call add(rv, '*')
    1              0.000001   endif
                            
    1              0.000003   if has_key(a:opts, 'nested') && a:opts.nested
                                call add(rv, '++nested')
    1              0.000001   endif
                            
    1              0.000002   if has_key(a:opts, 'once') && a:opts.once
                                call add(rv, '++once')
    1              0.000000   endif
                            
    1              0.000005   return join(rv, ' ')

FUNCTION  wildfire#Fuel()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:37
Called 4 times
Total time:   0.111540
 Self time:   0.000275

count  total (s)   self (s)
    8              0.000074     for i in range(a:repeat)
    4   0.111419   0.000154         cal s:select_text_object()
    8              0.000015     endfor

FUNCTION  <SNR>133_odd_quotes()
    Defined: ~/.local/share/nvim/lazy/wildfire.vim/autoload/wildfire.vim:219
Called 8 times
Total time:   0.001776
 Self time:   0.001776

count  total (s)   self (s)
    8              0.000027     let n = 0
  159              0.000310     for i in range(0, strlen(a:s))
  151              0.000746         if a:s[i] == a:quote && !(i > 0 && a:s[i-1] == "\\")
    8              0.000019             let n += 1
  151              0.000113         endif
  159              0.000142     endfor
    8              0.000031     return n % 2 != 0

FUNCTION  copilot#agent#Result()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/agent.vim:555
Called 87 times
Total time:   0.003086
 Self time:   0.003086

count  total (s)   self (s)
   87              0.000840   if has_key(a:request, 'resolve')
   87              0.000933     call add(a:request.resolve, a:callback)
                              elseif has_key(a:request, 'result')
                                let a:request.waiting[timer_start(0, function('s:Callback', [a:request, 'result', a:callback]))] = 1
   87              0.000117   endif

FUNCTION  <SNR>132_Count()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:444
Called 3 times
Total time:   0.000396
 Self time:   0.000396

count  total (s)   self (s)
    3              0.000035   let pat = escape(a:pattern, '\\')
    3              0.000010   if a:0 > 1
                                let foo = substitute(a:string, '[^' .. a:pattern .. ']', "a:1", "g")
                                let foo = substitute(a:string, pat, a:2, "g")
                                let foo = substitute(foo, '[^' .. a:2 .. ']', "", "g")
                                return strlen(foo)
    3              0.000004   endif
    3              0.000010   let result = 0
    3              0.000010   let foo = a:string
    3              0.000039   let index = matchend(foo, pat)
    5              0.000119   while index != -1
    2              0.000016     let result = result + 1
    2              0.000015     let foo = strpart(foo, index)
    2              0.000023     let index = matchend(foo, pat)
    5              0.000012   endwhile
    3              0.000009   return result

FUNCTION  GetLuaIndent()
    Defined: /usr/share/nvim/runtime/indent/lua.vim:29
Called 2 times
Total time:   0.000746
 Self time:   0.000746

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
    2              0.000051   let prevlnum = prevnonblank(v:lnum - 1)
                            
                              " Hit the start of the file, use zero indent.
    2              0.000017   if prevlnum == 0
                                return 0
    2              0.000004   endif
                            
                              " Add a 'shiftwidth' after lines that start a block:
                              " 'function', 'if', 'for', 'while', 'repeat', 'else', 'elseif', '{'
    2              0.000019   let ind = indent(prevlnum)
    2              0.000096   let prevline = getline(prevlnum)
    2              0.000130   let midx = match(prevline, '^\s*\%(if\>\|for\>\|while\>\|repeat\>\|else\>\|elseif\>\|do\>\|then\>\)')
    2              0.000018   if midx == -1
    2              0.000053     let midx = match(prevline, '{\s*$')
    2              0.000007     if midx == -1
    2              0.000060       let midx = match(prevline, '\<function\>\s*\%(\k\|[.:]\)\{-}\s*(')
    2              0.000007     endif
    2              0.000003   endif
                            
    2              0.000007   if midx != -1
                                " Add 'shiftwidth' if what we found previously is not in a comment and
                                " an "end" or "until" is not present on the same line.
                                if synIDattr(synID(prevlnum, midx + 1, 1), "name") != "luaComment" && prevline !~ '\<end\>\|\<until\>'
                                  let ind = ind + shiftwidth()
                                endif
    2              0.000002   endif
                            
                              " Subtract a 'shiftwidth' on end, else, elseif, until and '}'
                              " This is the part that requires 'indentkeys'.
    2              0.000105   let midx = match(getline(v:lnum), '^\s*\%(end\>\|else\>\|elseif\>\|until\>\|}\)')
    2              0.000032   if midx != -1 && synIDattr(synID(v:lnum, midx + 1, 1), "name") != "luaComment"
                                let ind = ind - shiftwidth()
    2              0.000003   endif
                            
    2              0.000010   return ind

FUNCTION  <SNR>23_ClearPreview()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:344
Called 188 times
Total time:   0.008538
 Self time:   0.006396

count  total (s)   self (s)
  188              0.000552   if s:has_nvim_ghost_text
  188   0.005210   0.003068     call nvim_buf_del_extmark(0, copilot#NvimNs(), 1)
                              elseif s:has_vim_ghost_text
                                call prop_remove({'type': s:hlgroup, 'all': v:true})
                                call prop_remove({'type': s:annot_hlgroup, 'all': v:true})
  188              0.000187   endif

FUNCTION  provider#clipboard#Call()
    Defined: /usr/share/nvim/runtime/autoload/provider/clipboard.vim:241
Called 104 times
Total time:   2.428357
 Self time:   0.016413

count  total (s)   self (s)
  104              0.003387   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
  104              0.000241   endif
  104              0.000817   let s:here = v:true
  104              0.000331   try
  104   2.419758   0.007813     return call(s:clipboard[a:method],a:args,s:clipboard)
  104              0.000432   finally
  104              0.001002     let s:here = v:false
  104              0.000547   endtry

FUNCTION  <SNR>132_CleanUp()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:249
Called 1 time
Total time:   0.000247
 Self time:   0.000125

count  total (s)   self (s)
    1              0.000003   if strlen(a:options)
    1   0.000164   0.000042     execute "set" a:options
    1              0.000001   endif
                              " Open folds, if appropriate.
    1              0.000003   if a:mode != "o"
    1              0.000006     if &foldopen =~ "percent"
    1              0.000042       normal! zv
    1              0.000001     endif
                                " In Operator-pending mode, we want to include the whole match
                                " (for example, d%).
                                " This is only a problem if we end up moving in the forward direction.
                              elseif (a:startpos[0] < line(".")) || (a:startpos[0] == line(".") && a:startpos[1] < col("."))
                                if a:0
                                  " Check whether the match is a single character.  If not, move to the
                                  " end of the match.
                                  let matchline = getline(".")
                                  let currcol = col(".")
                                  let regexp = s:Wholematch(matchline, a:1, currcol-1)
                                  let endcol = matchend(matchline, regexp)
                                  if endcol > currcol  " This is NOT off by one!
                                    call cursor(0, endcol)
                                  endif
                                endif " a:0
    1              0.000001   endif " a:mode != "o" && etc.
    1              0.000001   return 0

FUNCTION  provider#pythonx#Require()
    Defined: /usr/share/nvim/runtime/autoload/provider/pythonx.vim:8
Called 2 times
Total time:   0.828710
 Self time:   0.002198

count  total (s)   self (s)
                              " Python host arguments
    2   0.000078   0.000054   let prog = provider#python3#Prog()
    2              0.000018   let args = [prog, '-c', 'import sys; sys.path = [p for p in sys.path if p != ""]; import neovim; neovim.start_host()']
                            
                            
                              " Collect registered Python plugins into args
    2   0.000092   0.000042   let python_plugins = remote#host#PluginsForHost(a:host.name)
    6              0.000026   for plugin in python_plugins
    4              0.000033     call add(args, plugin.path)
    6              0.000011   endfor
                            
    2   0.828418   0.001980   return provider#Poll(args, a:host.orig_name, '$NVIM_PYTHON_LOG_FILE', {'overlapped': v:true})

FUNCTION  <SNR>57_rooter()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:72
Called 12 times
Total time:   0.018935
 Self time:   0.001312

count  total (s)   self (s)
   12   0.003102   0.000324   if !s:activate() | return | endif
                            
   12              0.000123   let root = getbufvar('%', 'rootDir')
   12              0.000056   if empty(root)
   12   0.014945   0.000264     let root = s:root()
   12              0.000110     call setbufvar('%', 'rootDir', root)
   12              0.000015   endif
                            
   12              0.000041   if empty(root)
                                call s:rootless()
                                return
   12              0.000010   endif
                            
   12   0.000387   0.000223   call s:cd(root)

FUNCTION  <SNR>132_InsertRefs()
    Defined: /usr/share/nvim/runtime/pack/dist/opt/matchit/autoload/matchit.vim:285
Called 1 time
Total time:   0.000585
 Self time:   0.000495

count  total (s)   self (s)
    1              0.000029   if a:matchline !~ a:prefix .. substitute(a:group, s:notslash .. '\zs:', '\\|', 'g') .. a:suffix
                                return a:group
    1              0.000001   endif
    1              0.000007   let i = matchend(a:groupBR, s:notslash .. ':')
    1              0.000003   let ini = strpart(a:groupBR, 0, i-1)
    1              0.000003   let tailBR = strpart(a:groupBR, i)
    1   0.000103   0.000013   let word = s:Choose(a:group, a:matchline, ":", "", a:prefix, a:suffix, a:groupBR)
    1              0.000008   let i = matchend(word, s:notslash .. ":")
    1              0.000003   let wordBR = strpart(word, i)
    1              0.000003   let word = strpart(word, 0, i-1)
                              " Now, a:matchline =~ a:prefix . word . a:suffix
    1              0.000002   if wordBR != ini
                                let table = s:Resolve(ini, wordBR, "table")
    1              0.000001   else
    1              0.000001     let table = ""
    1              0.000001     let d = 0
   11              0.000010     while d < 10
   10              0.000047       if tailBR =~ s:notslash .. '\\' .. d
                                    let table = table .. d
   10              0.000006       else
   10              0.000016         let table = table .. "-"
   10              0.000005       endif
   10              0.000012       let d = d + 1
   11              0.000007     endwhile
    1              0.000056   endif
    1              0.000003   let d = 9
   10              0.000009   while d
    9              0.000016     if table[d] != "-"
                                  let backref = substitute(a:matchline, a:prefix .. word .. a:suffix, '\' .. table[d], "")
                                    " Are there any other characters that should be escaped?
                                  let backref = escape(backref, '*,:')
                                  execute s:Ref(ini, d, "start", "len")
                                  let ini = strpart(ini, 0, start) .. backref .. strpart(ini, start+len)
                                  let tailBR = substitute(tailBR, s:notslash .. '\zs\\' .. d, escape(backref, '\\&'), 'g')
    9              0.000005     endif
    9              0.000010     let d = d-1
   10              0.000007   endwhile
    1              0.000003   if exists("b:match_debug")
                                if s:do_BR
                                  let b:match_table = table
                                  let b:match_word = word
                                else
                                  let b:match_table = ""
                                  let b:match_word = ""
                                endif
    1              0.000001   endif
    1              0.000003   return ini .. ":" .. tailBR

FUNCTION  <SNR>57_root()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:119
Called 12 times
Total time:   0.014681
 Self time:   0.007614

count  total (s)   self (s)
   12   0.001469   0.000351   let dir = s:current()
                            
                              " breadth-first search
   36              0.000104   while 1
   96              0.000353     for pattern in g:rooter_patterns
   72              0.002783       if pattern[0] == '!'
                                    let [p, exclude] = [pattern[1:], 1]
   72              0.000088       else
   72              0.000418         let [p, exclude] = [pattern, 0]
   72              0.000074       endif
   72   0.006828   0.001088       if s:match(dir, p)
   12              0.000035         if exclude
                                      break
   12              0.000010         else
   12              0.000026           return dir
                                    endif
   60              0.000063       endif
   84              0.000113     endfor
                            
   24   0.000643   0.000434     let [current, dir] = [dir, s:parent(dir)]
   36              0.000137     if current == dir | break | endif
   24              0.000051   endwhile
                            
                              return ''

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  104   2.428357   0.016413  provider#clipboard#Call()
  104   2.411944   0.023102  20()
  104   2.388842   0.027131  <SNR>115_try_cmd()
  341   2.307317   2.048868  provider#python3#Call()
    2   0.828992   0.000282  remote#host#Require()
    2   0.828710   0.002198  provider#pythonx#Require()
    2   0.824475             provider#Poll()
   71   0.696193   0.696184  UltiSnips#CursorMoved()
   60   0.694500             cmp_nvim_ultisnips#get_current_snippets()
    1   0.571400   0.000159  remote#define#AutocmdBootstrap()
  137   0.358847             UltiSnips#TrackChange()
 1107   0.251470   0.220638  <SNR>87_Highlight_Matching_Pair()
   87   0.192417   0.008971  <SNR>23_Trigger()
   87   0.183446   0.006557  copilot#Suggest()
   87   0.176889   0.030648  copilot#Complete()
  123   0.126398   0.004620  <SNR>22_Event()
    4   0.113273   0.000291  wildfire#Start()
    4   0.111540   0.000275  wildfire#Fuel()
    4   0.111265   0.006604  <SNR>133_select_text_object()
   92   0.101483   0.004721  copilot#Request()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  341   2.307317   2.048868  provider#python3#Call()
    2              0.824475  provider#Poll()
   71   0.696193   0.696184  UltiSnips#CursorMoved()
   60              0.694500  cmp_nvim_ultisnips#get_current_snippets()
  137              0.358847  UltiSnips#TrackChange()
 1107   0.251470   0.220638  <SNR>87_Highlight_Matching_Pair()
   92   0.092362   0.078044  <SNR>116_LspRequest()
   23              0.076107  <SNR>109_SynSet()
   32   0.093690   0.070320  <SNR>133_select()
   10              0.063459  <SNR>1_LoadFTPlugin()
    2   0.047989   0.046484  UltiSnips#JumpForwards()
   25              0.039336  Fcitx2en()
  188   0.080073   0.036998  <SNR>23_UpdatePreview()
  247   0.042974   0.035591  <SNR>116_OnResponse()
  188   0.033127   0.031953  <SNR>23_SuggestionTextWithAdjustments()
   24              0.031415  Fcitx2zh()
 1107              0.030833  <SNR>87_Remove_Matches()
   87   0.176889   0.030648  copilot#Complete()
  104   2.388842   0.027131  <SNR>115_try_cmd()
    1   0.027930   0.026989  UltiSnips#Anon()

